#+TITLES: Database concept
#+KEYWORDS: database
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t c:nil
#+OPTIONS: creator:nil d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t
#+OPTIONS: num:t p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t timestamp:t
#+OPTIONS: title:t toc:t todo:t |:t
#+DATE: <2017-06-05 Mon>
#+AUTHORS: weiwu
#+EMAIL: victor.wuv@gmail.com
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 24.5.1 (Org mode 8.3.4)
#+SETUPFILE: ../configOrg/level1.org

* Rational Algebra
** Basic
- select $\sigma_{P}(r)$
- project $\Pi_{S}(r)$
- rename $\rho_{x(A_1,A_2,...,A_n)}(r)$
- union $r\cup s$
- difference $r-s$
- cartesian-product $r\times s$
** Addition
- intersection $r\cap s = r-(r-s)$
- natual join $r\Join s = \Pi_{R\cup S}(\sigma_{r.A_1=s.A_1 \land ...}(r\times s))$
  - theta join $r\Join_{\theta}s = \sigma_{\theta}(r\times s)$
- devision

  $$temp1 \leftarrow \Pi_{R-S}(r)$$
  $$temp2 \leftarrow \Pi_{R-S}((temp1\times s) - \Pi_{R-S,S}(r))$$
  $$result = temp1 - temp2$$

  #+CAPTION: R
  | Student | Task      |
  |---------+-----------|
  | Peter   | Database1 |
  | Peter   | Database2 |
  | Peter   | Compiler1 |
  | Sara    | Database1 |
  | Sara    | Database2 |
  | Mary    | Database1 |
  | Mary    | Comipler1 |

  #+CAPTION: S
  | Task      |
  |-----------|
  | Database1 |
  | Database2 |

  #+CAPTION: R\div S
  | Student |
  |---------|
  | Peter   |
  | Sara    |

- aggregation $group_column\zeta_{aggre\_func(column)}(r)$
** Modification
- delete $r\leftarrow r - E$
- insert $r\leftarrow r\cup E$
- update $r\leftarrow \Pi_{F_1,F_2,...,F_n}(r)$
* SQL Language
** Command
*** CREATE & DROCY041670521US 11183 - Google Search
- select table owner:
#+BEGIN_SRC
SELECT owner,Table_name FROM all_tables WHERE owner='identified above' ORDER BY owner,Table_name ;
#+END_SRC

P & ALTER
#+BEGIN_SRC sql
  CREATE DATABASE dbname;
  USE DATABASE dbname;
  CREATE TABLE table_name (column_name TYPE Constrains, ... );
  DESC table_name;
  DROP TABLE;
  ALTER TABLE table_name

  ADD COLUMN columnName ...
  ADD PRIMARY KEY (columnName)
  RENAME TO tableNewName
  CHANGE COLUMN columnOldName columnNewName TYPE ...
  MODIFY COLUMN columnName TYPE...
  DROP COLUMN columnName
#+END_SRC
*** INSERT & UPDATE & DELETE
#+BEGIN_SRC sql
  INSERT INTO tableName [(columnName1, columnName2, ...)] VALUES ('value1', 'value2', ...);
  UPDATE tableName SET columnName1 = 'value1', columnName2 = 'value2' WHERE expr;
  DELETE FROM tableName WHERE expr;
#+END_SRC

*** Other Keywords
- REGEXP pattern
- IN ('value1', 'value2', ...)
- columnName BETWEEN value1 and value2

  Equivalent to "columnName > value1 and columnName < value2"

- NOT
  #+BEGIN_VERSE
  When 'NOT' use with 'BETWEEN' and 'LIKE', 'NOT' must follow with 'WHERE' or 'AND/OR'.
  'NOT IN' is an exception. "IS NOT NULL" also.
  #+END_VERSE

- SHOW
  #+BEGIN_SRC sql
    SHOW CREATE TABLE tableName;
    SHOW COLUMNS FROM tableName;
    SHOW INDEX FROM tableName;
    SHOW WARNINGS;
  #+END_SRC


- FIRST, LAST, BEFORE, AFTER, SECOND...

- CASE
  #+BEGIN_SRC sql
    UPDATE tableName SET columnName =
hznl    CASE
      WHEN column_1 = somevalue1
        THEN newValue;
  #+END_SRC

- ORDER BY

  ORDER BY columnName [ASC/DESC]

- SUM, AVG, MAX, MIN, COUNT
  - match with GROUP_BY

	E.g:SUM(columnName) ... GROUP BY columnName

- GROUP BY

  remove the duplicates
  - SELECT columnName1, columnName2 FROM tableName GROUP BY columnName2

- Having

  The HAVING clause was added to SQL because the WHERE keyword could not be used with aggregate functions.
  E.g: HAVING count(columnName) > 5


- EXISTS, NOT EXISTS are always using in corelated subquery.

- UNION
  - Suppress the duplicates by default. UNION ALL can keep the duplicates.

- WITH

  Define temporary view
  #+BEGIN_SRC sql
    WITH temp_view_name(columnName...) as
         select statement
    SELECT ...
    FROM temp_view_name
    WHERE ...
  #+END_SRC

- RECURSIVE
  - CREAT RECURSIVE VIEW
  - WITH RECURSIVE
  #+BEGIN_SRC sql
    WITH RECURSIVE empl(employee_name, manager_name) as (
         SELECT employee_name, manager_name
         FROM manager
        UNION
         SELECT manager.employee_name,empl.manager_name
         FROM manager, empl
         WHERE manager.manager_name = empl.employee_name
    )
    SELECT *
    FROM empl
  #+END_SRC

- GRANT & REVOKE
  - GRANT statement ON table TO who
  - REVOKE statement ON table FROM who

- deadlock, ORA-00054: 资源正忙，要求指定 NOWAIT
#+BEGIN_SRC sql
select * from v$locked_object;

select object_name,machine,s.sid,s.serial#
from v$locked_object l,dba_objects o ,v$session s
where l.object_id　=　o.object_id and l.session_id=s.sid;


alter system kill session '83, 23941'
#+END_SRC
** Datatype
CHAR, VARCHAR, BLOB, INT, DEC, DATE, DATETIME
** Join
*** Overview
#+ATTR_HTML: align="center"
[[file:../resources/data/sqljoins.png]]
*** Inner Join
#+BEGIN_VERSE
An inner join is just a cartesian join with
some result rows removed by a condition in the query.
#+END_VERSE
#+BEGIN_SRC sql
select * from table_a a
inner join * from table_b b
#+END_SRC
** Subquery
*** Noncorrelated Subquery
#+BEGIN_VERSE
A subquery that stands alone and doesn't reference
anything from the outer query.

RDBMS will excute inner first, then excute outer.
#+END_VERSE
*** Correlated Subquery
#+BEGIN_VERSE
A subquery that relies on values returned from
the outer query.(Slow)
#+END_VERSE

* Design
** Steps
1) Find *the one thing* need to be described.
2) List *necessary* information about this thing.(Depends on how to use this table)
3) Break down the information *into pieces* .

** Schema Pattern
*** One to One
**** When to use
1) Allow you to write fast queries.
2) If you have a column containing values you don't yet know.Iso NULL value.
3) Make data less accessible.
4) To store a large piece of data, like BLOB.
*** One to Many
*** Many to Many
use junction table.

** Functional Dependency
*** Definition
$$\forall t,u \in R\  (t[\bar A]= u[\bar A]) \to (t[\bar B] = u[\bar B])$$
*** Functional Dependency
#+BEGIN_VERSE
If we have a functional dependency $\bar A \to \bar B$,
#+END_VERSE
- Trivial

  $\bar B \subseteq \bar A$ and $\bar A \to \bar A \cup \bar B$ elso.

- Nontrivial

  $\bar B \nsubseteq \bar A$

- Completely nontrivial

  $\bar A \cap \bar B = \emptyset$

**** Partial Functional Dependency
When a non-key column is dependent on some, but not all, of the composite PK.

**** Transitive Functional Dependency
When any non-key column is dependent on any of the other non-key columns.

*** Rules For FD
- Splitting rule

  If $\bar A \to B_1, B_2$ , then $\bar A \to B_1\ \bar A \to B_2$

- Combining rule

  If $\bar A \to B_1\ \bar A \to B_2$, then $\bar A \to B_1, B_2$

- Transitive rule

  If $\bar A \to \bar B$ and $\bar B \to \bar C$, then $\bar A \to \bar C$

*** Closure of Attributes
#+BEGIN_VERSE
Given relation, FDs, set of attributes $\bar A$
Find all B such that $\bar A \to B$ .
#+END_VERSE

** Multivalued Dependency
*** Definition
#+BEGIN_VERSE
$\forall t, u\in R:\ t[\bar A] = u[\bar A]$ then
$\exists v \in R:$
$v[\bar A] = t[\bar A]$ and
$v[\bar B] = t[\bar B]$ and
$v[rest] = u[rest]$

MVD says, If two tuples have same value for $\bar A$,
then we have *every* combination for $\bar B$ value and the rest.
#+END_VERSE
| tuple | $\bar A$ | $\bar B$   | rest       |
|-------+----------+------------+------------|
| t     | $\bar a$ | $\bar b_1$ | $\bar r_1$ |
| u     | $\bar a$ | $\bar b_2$ | $\bar r_2$ |
| v     | $\bar a$ | $\bar b_1$ | $\bar r_2$ |
#+BEGIN_VERSE
Note that, there aslo must exist w:
#+END_VERSE
| w | $\bar a$ | $\bar b_2$ | $\bar r_1$ |

- Trivial MVDs

  #+BEGIN_VERSE
  $\bar B\subseteq \bar A$ or $\bar A\cup \bar B = all\ attributes$
  always satisfied MVD.

  E.g. for first case, Consider $\bar{AB} \twoheadrightarrow \bar B$.
  #+END_VERSE

- Nontrivial

  otherwise.

MVD is a *tuple-generating* dependency.

*** Rules For MVD
- FD is a MVD
- Intersection rule

  If $(\bar A\twoheadrightarrow \bar B) \land (\bar A\twoheadrightarrow \bar C)$ ,
  then $\bar A\twoheadrightarrow \bar B\cap \bar C$ .

- Transitive rule

  If $(\bar A\twoheadrightarrow \bar B) \land (\bar B\twoheadrightarrow \bar C)$ ,
  then $\bar A\twoheadrightarrow \bar C - \bar B$ .

* Normalization
** 1NF
#+BEGIN_VERSE
Data in your column is atomic if it's been broken
down into the smallest pieces that you need.
#+END_VERSE

- Rule 1:
  #+BEGIN_VERSE
  A column with atomic data can't have several values of
  the same type of data in that column.
  One example obeys the rule 1:
  #+END_VERSE
  | food_name | ingredients                  |
  |-----------+------------------------------|
  | bread     | flour, milk, egg, yeast, oil |
  | salad     | lettuce, tomato, cucumber    |

- Rule 2:
  #+BEGIN_VERSE
  A table with atomic data can't have multiple columns
  with the same type of data.
  #+END_VERSE
  | teacher | student1 | student2 |
  |---------+----------+----------|
  | Ms.Mary | Joe      | Ron      |

** 2NF
- Rule 1: Be in 1NF
- Rule 2: Have no partial functional dependencies.

** 3NF
- Rule 1: Be in 2NF
- Rule 2: Have no transitive dependencies.

** Boyce-Codd Normal Form(BCNF, 3.5NF)
FD leads to the BCNF.
- Definition
  #+BEGIN_VERSE
  Relation R with FDs is in BCNF if:
  For each  nontrivial $\bar A\to B$, $\bar A$ is a key.
  #+END_VERSE
*** Validation Example
#+BEGIN_VERSE
R(A, B, C, D)
FDs: $AC\to D,\ D\to A,\ D\to C,\ D\to B$
For every $\bar{left}$ can determine all the attributes.
#+END_VERSE

** 4NF
- Definition
  #+BEGIN_VERSE
  Relation R with MVDs is in 4NF if:
  For each nontrivial $\bar A\twoheadrightarrow \bar B$, A is a key.
  #+END_VERSE
4NF is in BCNF.

* Subclasses
** Complete vs. Incomplete(Partial)
Complete: Every object is in at least one subclass.
** Overlapping vs. Disjoint(Exclusive)
Overlapping: One object is in two+ subclasses.
** How to design?
3 choices:
1) Subclass relations contain superclass key + specialized attrs
2) Subclass relations contain all attributes
3) One relation containing all superclass + subclass attrs
#+BEGIN_VERSE
Best translation may depend on properties:
Heavily overlapping -> design 3
Disjoint, complete ->design 2
#+END_VERSE
Examples:
# #+BEGIN_SRC plantuml :file ../resources/data/SubclassExample.png :cmdline -charset UTF-8
# @startuml
# title Subclass Example
# Superclass <|-- Subclass1
# Superclass <|-- Subclass2
# class Superclass{
# k PK
# A
# }

# class Subclass1{
# B
# }

# class Subclass2{
# C
# }
# @enduml
# #+END_SRC

# #+results:
# [[file:../resources/data/SubclassExample.png]]

1) S(_K_, A), S1(_K_, B), S2(_K_, C)
2) S(_K_, A), S1(_K_, A, B), S2(_K_, A, C)
3) S(_K_, A, B, C)
* Constraints
** Motivation
Constrain allowable database states.(static)

** Syntax
Major keywords: PK, FK, UNIQUE, CHECK


- Examples:
#+BEGIN_SRC sql
Create ...
{
    columnName type CHECK (columnName IN ('value1', 'value2'));
}

ADD CONSTRAINT CHECK columnName > 1;

CHECK 'A' = SUBSTRING(columnName, 1, 1);
#+END_SRC

** Foreign Key
*** Facts
1) A FK can have different name than the parent key.
2) FK values can be NULL.
3) We can make sure a FK contains a meaningful value by using a *constraint* .
4) The FK doesn't have to be the primary key of the parent table, but it must be unique.
*** Creation
#+BEGIN_SRC sql
  CREATE TABLE tableName
  (
      ...
      columnName TYPE NOT NULL,
      [CONSTRAINT constraint_name,]
      FOREIGN KEY (foreign_key_name)
      REFERENCES parent_tableName (parent_columnName)
  )
#+END_SRC
You can name constraint_name and foreign_key_name whatever you like.

* Triggers
** Motivation
- To enforce constraints(Dynamic)
- Move logic from apps into DBMS

** Usage
- Event-Condition-Action Rules

  When *event* occurs, check *condition*; if true, do *action*.

- Syntax
  #+BEGIN_VERSE
  Create Trigger *name*
  Before|After|Instead of *events*
  *[referencing-variables]*
  [For Each Row]
  [when (*condition*)]
  *action*
  #+END_VERSE
  - events
    #+BEGIN_VERSE
    insert on T
    delete on T
    update [of C1,...,Cn] on T
    #+END_VERSE

  - [For Each Row]

    Determines whether the trigger is row-level or statement-level

  - referencing-variables
    #+BEGIN_VERSE
    Depends on [For Each Row]
    old row as *var*
    new row as *var*
    old table as *var*
    new table as *var*
    #+END_VERSE

  - condition

    In /when/ or /where/ clause depends on the SQL Implementation.

* Indexes
** Usage
Different between full table scans and immediate location of tuples.
** Underlying Data Structures
- Balanced trees (B tree, B+ tree)

  When uses ">, <, >=, <=" in query.
- Hashtable

  When uses "=" in query.
** SQL Syntax
#+BEGIN_SRC sql
  CREATE INDEX IndexName ON T(A1,A2...)
  CREATE UNIQUE INDEX ...
  DROP INDEX IndexName
#+END_SRC
** Downsides
- Extra space
- Index creation
- Index maintenance(Important)

  When updates database, indexes will also be updated.
** Upsides
Benefits depends on:

- Data distributions
- Query vs. update load
- Size of table(and possibly layout)
** Physical Design Advisors
- Input (database statistics and workload)
- Output (recommended indexes)

#+ATTR_HTML: align="center"
[[file:../resources/data/QueryOptimizer.png]]

* Transaction
** Motivation
- Concurrent database access
- Resilience to system failures
** Properties
- A(Atomicity)

  Each transaction is "all-or-nothing", never left half done.

- C(Consistency)
  #+BEGIN_VERSE
  Can assume all constrants hold when transaction begins.
  Must guarantee all constraints hold when transaction ends.
  Serializability -> constraints always hold
  #+END_VERSE
- I(Isolation)
  #+BEGIN_VERSE
  Serializability: Execution must be equivalent to some
  sequential(serial) order of all transactions.(e.g. T9, T1, T2, T3, ...)
  #+END_VERSE
- D(Durability)
  #+BEGIN_VERSE
  If system crashes after transaction commits,
  all effects of transaction remain in database.
  #+END_VERSE
** Isolation levels
- dirty data: written by an uncommitted transaction
- nonrepeatable reads: an item read multiple times cannot change values
  #+BEGIN_EXAMPLE
  T1:    Update Student Set GPA=(1.1)*GPA
  T2.S1: Select AVG(GPA) From Student
  T2.S2: Select MAX(GPA) From Student
  #+END_EXAMPLE
  #+BEGIN_VERSE
  T2.S1 may excute before T1, T2.S2 may excute after T1.
  The GPAs in S1 and S2 are different, leads to a nonrepatable reads violation.
  #+END_VERSE
- phantoms
  #+BEGIN_EXAMPLE
  T1:    Insert Into Student [100 new tuples]
  T2.S1: Select AVG(GPA) From Student
  T2.S2: Select MAX(GPA) From Student
  #+END_EXAMPLE
  #+BEGIN_VERSE
  T2.S1 may excute before T1, T2.S2 may excute after T1.
  [100 new tuples] are known as the phantoms tuples.
  #+END_VERSE

| levels           | dirty reads | nonrepeatable reads | phantoms |
|------------------+-------------+---------------------+----------|
| Read Uncommitted | Y           | Y                   | Y        |
| Read Committed   | N           | Y                   | Y        |
| Repeatable Read  | N           | N                   | Y        |
| Serializable     | N           | N                   | N        |

- Standard default: *Serializable*
- Some systems have default *Repeatable Read*
* SQL Statements
** Syntax for SQL Statements

SQL statements are the means by which programs and users access data in an Oracle database.

The sections that follow show each SQL statement and its related syntax. Refer to [Chapter 5, "Subclauses"](sqlqr05.htm#g1004143) for the syntax of the subclauses listed in the syntax for the statements.

#+BEGIN_SRC txt


See Also:

Oracle Database SQL Language Reference for detailed information about Oracle SQL
#+END_SRC

- [ALTER CLUSTER]

#+BEGIN_SRC sql
ALTER CLUSTER [ schema. ]cluster
  { physical_attributes_clause
  | SIZE size_clause
  | allocate_extent_clause
  | deallocate_unused_clause
  | { CACHE | NOCACHE }
  } ...
  [ parallel_clause ] ;
#+END_SRC

- [ALTER DATABASE]

#+BEGIN_SRC sql
ALTER DATABASE [ database ]
  { startup_clauses
  | recovery_clauses
  | database_file_clauses
  | logfile_clauses
  | controlfile_clauses
  | standby_database_clauses
  | default_settings_clauses
  | instance_clauses
  | security_clause
  } ;
#+END_SRC

- [ALTER DATABASE LINK]

#+BEGIN_SRC sql
ALTER DATABASE LINK dblink
  { CONNECT TO user IDENTIFIED BY password [ dblink_authentication ]
  | dblink_authentication
  };
#+END_SRC

- [ALTER DIMENSION]

#+BEGIN_SRC sql
ALTER DIMENSION [ schema. ] dimension
  { ADD { level_clause
        | hierarchy_clause
        | attribute_clause
        | extended_attribute_clause
        }
  } ...
  |
  { DROP { LEVEL level [ RESTRICT | CASCADE ]
         | HIERARCHY hierarchy
         | ATTRIBUTE attribute [ LEVEL level [ COLUMN column ] ]...
         }
  } ...
  |
  COMPILE
  ;
#+END_SRC

- [ALTER DISKGROUP]

#+BEGIN_SRC sql
ALTER DISKGROUP
  { diskgroup_name
      { { { add_disk_clause | drop_disk_clause }
          [, { add_disk_clause | drop_disk_clause } ]...
        | resize_disk_clause
        } [ rebalance_diskgroup_clause ]
      | disk_online_clause
      | disk_offline_clause
      | rebalance_diskgroup_clause
      | check_diskgroup_clause
      | diskgroup_template_clauses
      | diskgroup_directory_clauses
      | diskgroup_alias_clauses
      | diskgroup_volume_clauses
      | diskgroup_attributes
      | modify_diskgroup_file
      | drop_diskgroup_file_clause
      | usergroup_clauses
      | user_clauses
      | file_permissions_clause
      | file_owner_clause
      }
    | { diskgroup_name [, diskgroup_name ] ...
      | ALL
      } { undrop_disk_clause
        | diskgroup_availability
        | enable_disable_volume
        }
  } ;
#+END_SRC

- [ALTER FLASHBACK ARCHIVE]

#+BEGIN_SRC sql
ALTER FLASHBACK ARCHIVE flashback_archive
  { SET DEFAULT
  | { ADD | MODIFY } TABLESPACE tablespace [flashback_archive_quota]
  | REMOVE TABLESPACE tablespace_name
  | MODIFY RETENTION flashback_archive_retention
  | PURGE { ALL | BEFORE { SCN expr | TIMESTAMP expr } }
  | [NO] OPTIMIZE DATA
  };
#+END_SRC

#+BEGIN_SRC txt


Note:

You can specify the `[NO]` `OPTIMIZE` `DATA` clause in this statement starting with Oracle Database 11g Release 2 (11.2.0.4).
#+END_SRC

- [ALTER FUNCTION]

#+BEGIN_SRC sql
ALTER FUNCTION [ schema. ] function function_compile_clause
#+END_SRC

- [ALTER INDEX]

#+BEGIN_SRC sql
ALTER INDEX [ schema. ]index
  { { deallocate_unused_clause
    | allocate_extent_clause
    | shrink_clause
    | parallel_clause
    | physical_attributes_clause
    | logging_clause
    } ...
  | rebuild_clause
  | PARAMETERS ( 'ODCI_parameters' )
               )
  | COMPILE
  | { ENABLE | DISABLE }
  | UNUSABLE
  | VISIBLE | INVISIBLE
  | RENAME TO new_name
  | COALESCE
  | { MONITORING | NOMONITORING } USAGE
  | UPDATE BLOCK REFERENCES
  | alter_index_partitioning
  }
  ;
#+END_SRC

- [ALTER INDEXTYPE]

#+BEGIN_SRC sql
ALTER INDEXTYPE [ schema. ] indextype
  { { ADD | DROP } [ schema. ] operator ( parameter_types )
      [ , { ADD | DROP } [schema. ] operator ( parameter_types ) ]... [ using_type_clause ]
  | COMPILE
  }
  [ WITH LOCAL [ RANGE ] PARTITION ] [ storage_table_clause ]
  ;
#+END_SRC

- [ALTER JAVA]

#+BEGIN_SRC sql
ALTER JAVA
  { SOURCE | CLASS } [ schema. ]object_name
  [ RESOLVER
      ( ( match_string [, ] { schema_name | - } )... )
  ]
  { { COMPILE | RESOLVE }
  | invoker_rights_clause
  } ;
#+END_SRC

- [ALTER LIBRARY]

#+BEGIN_SRC sql
ALTER LIBRARY [ schema. ] library_name library_compile_clause
#+END_SRC

- [ALTER MATERIALIZED VIEW]

#+BEGIN_SRC sql
ALTER MATERIALIZED VIEW
  [ schema. ] materialized_view
  [ physical_attributes_clause
  | modify_mv_column_clause
  | table_compression
  | LOB_storage_clause [, LOB_storage_clause ]...
  | modify_LOB_storage_clause [, modify_LOB_storage_clause ]...
  | alter_table_partitioning
  | parallel_clause
  | logging_clause
  | allocate_extent_clause
  | deallocate_unused_clause
  | shrink_clause
  | { CACHE | NOCACHE }
  ]
  [ alter_iot_clauses ]
  [ USING INDEX physical_attributes_clause ]
  [ MODIFY scoped_table_ref_constraint
  | alter_mv_refresh
  ]
  [ { ENABLE | DISABLE } QUERY REWRITE
  | COMPILE
  | CONSIDER FRESH
  ] ;
#+END_SRC

- [ALTER MATERIALIZED VIEW LOG]

#+BEGIN_SRC sql
ALTER MATERIALIZED VIEW LOG [ FORCE ]
  ON [ schema. ]table
  [ physical_attributes_clause
  | add_mv_log_column_clause
  | alter_table_partitioning
  | parallel_clause
  | logging_clause
  | allocate_extent_clause
  | shrink_clause
  | move_mv_log_clause
  | { CACHE | NOCACHE }
  ] [ mv_log_augmentation ] [  mv_log_purge_clause ]
  ;
#+END_SRC

- [ALTER OPERATOR]

#+BEGIN_SRC sql
ALTER OPERATOR [ schema. ] operator
  { add_binding_clause
  | drop_binding_clause
  | COMPILE
  } ;
#+END_SRC

- [ALTER OUTLINE]

#+BEGIN_SRC sql
ALTER OUTLINE [ PUBLIC | PRIVATE ] outline
  { REBUILD
  | RENAME TO new_outline_name
  | CHANGE CATEGORY TO new_category_name
  | { ENABLE | DISABLE }
  } ...
  ;
#+END_SRC

- [ALTER PACKAGE]

#+BEGIN_SRC sql
ALTER PACKAGE [ schema. ] package package_compile_clause
#+END_SRC

- [ALTER PROCEDURE]

#+BEGIN_SRC sql
ALTER PROCEDURE [ schema. ] procedure procedure_compile_clause
#+END_SRC

- [ALTER PROFILE]

#+BEGIN_SRC sql
ALTER PROFILE profile LIMIT
  { resource_parameters | password_parameters } ...
  ;
#+END_SRC

- [ALTER RESOURCE COST]

#+BEGIN_SRC sql
ALTER RESOURCE COST
  { { CPU_PER_SESSION
    | CONNECT_TIME
    | LOGICAL_READS_PER_SESSION
    | PRIVATE_SGA
    } integer
  } ...
  ;
#+END_SRC

- [ALTER ROLE]

#+BEGIN_SRC sql
ALTER ROLE role
  { NOT IDENTIFIED
  | IDENTIFIED
      { BY password
      | USING [ schema. ] package
      | EXTERNALLY
      | GLOBALLY
      }
  } ;
#+END_SRC

- [ALTER ROLLBACK SEGMENT]

#+BEGIN_SRC sql
ALTER ROLLBACK SEGMENT rollback_segment
  { ONLINE
  | OFFLINE
  | storage_clause
  | SHRINK [ TO size_clause ]
  };
#+END_SRC

- [ALTER SEQUENCE]

#+BEGIN_SRC sql
ALTER SEQUENCE [ schema. ] sequence
  { INCREMENT BY integer
  | { MAXVALUE integer | NOMAXVALUE }
  | { MINVALUE integer | NOMINVALUE }
  | { CYCLE | NOCYCLE }
  | { CACHE integer | NOCACHE }
  | { ORDER | NOORDER }
  } ...
  ;
#+END_SRC

- [ALTER SESSION]

#+BEGIN_SRC sql
ALTER SESSION
  { ADVISE { COMMIT | ROLLBACK | NOTHING }
  | CLOSE DATABASE LINK dblink
  | { ENABLE | DISABLE } COMMIT IN PROCEDURE
  | { ENABLE | DISABLE } GUARD
  | { ENABLE | DISABLE | FORCE } PARALLEL
    { DML | DDL | QUERY } [ PARALLEL integer ]
  | { ENABLE RESUMABLE [ TIMEOUT integer ] [ NAME string ]
    | DISABLE RESUMABLE
    }
  | SYNC WITH PRIMARY
  | alter_session_set_clause
  } ;
#+END_SRC

- [ALTER SYSTEM]

#+BEGIN_SRC sql
ALTER SYSTEM
  { archive_log_clause
  | checkpoint_clause
  | check_datafiles_clause
  | distributed_recov_clauses
  | FLUSH { SHARED_POOL | GLOBAL CONTEXT | BUFFER_CACHE
          | REDO TO target_db_name [ [ NO ] CONFIRM APPLY ] }
  | end_session_clauses
  | SWITCH LOGFILE
  | { SUSPEND | RESUME }
  | quiesce_clauses
  | rolling_migration_clauses
  | security_clauses
  | shutdown_dispatcher_clause
  | REGISTER
  | SET alter_system_set_clause
        [ alter_system_set_clause ]...
  | RESET alter_system_reset_clause
          [ alter_system_reset_clause ]...
  } ;
#+END_SRC

- [ALTER TABLE]

#+BEGIN_SRC sql
ALTER TABLE [ schema. ] table
  [ alter_table_properties
  | column_clauses
  | constraint_clauses
  | alter_table_partitioning
  | alter_external_table
  | move_table_clause
  ]
  [ enable_disable_clause
  | { ENABLE | DISABLE } { TABLE LOCK | ALL TRIGGERS }
  ] ...
  ;
#+END_SRC

- [ALTER TABLESPACE]

#+BEGIN_SRC sql
ALTER TABLESPACE tablespace
  { DEFAULT [ table_compression ] [ storage_clause ]
  | MINIMUM EXTENT size_clause
  | RESIZE size_clause
  | COALESCE
  | SHRINK SPACE [ KEEP size_clause]
  | RENAME TO new_tablespace_name
  | { BEGIN | END } BACKUP
  | datafile_tempfile_clauses
  | tablespace_logging_clauses
  | tablespace_group_clause
  | tablespace_state_clauses
  | autoextend_clause
  | flashback_mode_clause
  | tablespace_retention_clause
  } ;
#+END_SRC

- [ALTER TRIGGER]

#+BEGIN_SRC sql
ALTER TRIGGER [ schema. ] trigger
  { ENABLE
  | DISABLE
  | RENAME TO new_name
  | trigger_compile_clause
  } ;
#+END_SRC

- [ALTER TYPE]

#+BEGIN_SRC sql
ALTER TYPE [ schema. ]type alter_type_clauses
#+END_SRC

- [ALTER USER]

#+BEGIN_SRC sql
ALTER USER
  { user
    { IDENTIFIED
      { BY password [ REPLACE old_password ]
      | EXTERNALLY [ AS 'certificate_DN' | AS 'kerberos_principal_name' ]
      | GLOBALLY [ AS '[directory_DN]' ]
      }
    | DEFAULT TABLESPACE tablespace
    | TEMPORARY TABLESPACE { tablespace | tablespace_group_name }
    | { QUOTA { size_clause
              | UNLIMITED
              } ON tablespace
      } ...
    | PROFILE profile
    | DEFAULT ROLE { role [, role ]...
                   | ALL [ EXCEPT role [, role ] ... ]
                   | NONE
                   }
    | PASSWORD EXPIRE
    | ACCOUNT { LOCK | UNLOCK }
    | ENABLE EDITIONS [ FORCE ]
    } ...
  | user [, user ]... proxy_clause
  } ;
#+END_SRC

- [ALTER VIEW]

#+BEGIN_SRC sql
ALTER VIEW [ schema. ] view
  { ADD out_of_line_constraint
  | MODIFY CONSTRAINT constraint
      { RELY | NORELY }
  | DROP { CONSTRAINT constraint
         | PRIMARY KEY
         | UNIQUE (column [, column ]...)
         }
  | COMPILE
  | { READ ONLY | READ WRITE }
  } ;
#+END_SRC

- [ANALYZE]

#+BEGIN_SRC sql
ANALYZE
  { { TABLE [ schema. ] table
    | INDEX [ schema. ] index
    } [ partition_extension_clause ]
  | CLUSTER [ schema. ] cluster
  }
  { validation_clauses
  | LIST CHAINED ROWS [ into_clause ]
  | DELETE [ SYSTEM ] STATISTICS
  } ;
#+END_SRC

- [ASSOCIATE STATISTICS]

#+BEGIN_SRC sql
ASSOCIATE STATISTICS WITH
  { column_association | function_association }
  [ storage_table_clause ] ;
#+END_SRC

- [AUDIT]

#+BEGIN_SRC sql
AUDIT
  { audit_operation_clause [ auditing_by_clause | IN SESSION CURRENT ]
  | audit_schema_object_clause
  | NETWORK
  } [ BY { SESSION | ACCESS } ]
    [ WHENEVER [ NOT ] SUCCESSFUL ]
;
#+END_SRC

- [CALL]

#+BEGIN_SRC sql
CALL
  { routine_clause
  | object_access_expression
  }
  [ INTO :host_variable
    [ [ INDICATOR ] :indicator_variable ] ] ;
#+END_SRC

- [COMMENT]

#+BEGIN_SRC sql
COMMENT ON
  { COLUMN [ schema. ]
    { table. | view. | materialized_view. } column
  | EDITION edition_name
  | INDEXTYPE [ schema. ] indextype
  | MATERIALIZED VIEW materialized_view
  | MINING MODEL [ schema. ] model
  | OPERATOR [ schema. ] operator
  | TABLE [ schema. ] { table | view }
  }
  IS string ;
#+END_SRC

- [COMMIT]

#+BEGIN_SRC sql
COMMIT [ WORK ]
  [ [ COMMENT string ]
    | [ WRITE [ WAIT | NOWAIT ] [ IMMEDIATE | BATCH ]
    ]
  | FORCE string [, integer ]
  ] ;
#+END_SRC

- [CREATE CLUSTER]

#+BEGIN_SRC sql
CREATE CLUSTER [ schema. ] cluster
  (column datatype [ SORT ]
    [, column datatype [ SORT ] ]...
  )
  [ { physical_attributes_clause
    | SIZE size_clause
    | TABLESPACE tablespace
    | { INDEX
      | [ SINGLE TABLE ]
        HASHKEYS integer [ HASH IS expr ]
      }
    }...
  ]
  [ parallel_clause ]
  [ NOROWDEPENDENCIES | ROWDEPENDENCIES ]
  [ CACHE | NOCACHE ] ;
#+END_SRC

- [CREATE CONTEXT]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] CONTEXT namespace
  USING [ schema. ] package
  [ INITIALIZED { EXTERNALLY | GLOBALLY }
  | ACCESSED GLOBALLY
  ] ;
#+END_SRC

- [CREATE CONTROLFILE]

#+BEGIN_SRC sql
CREATE CONTROLFILE
  [ REUSE ] [ SET ] DATABASE database
  [ logfile_clause ]
  { RESETLOGS | NORESETLOGS }
  [ DATAFILE file_specification
             [, file_specification ]... ]
  [ MAXLOGFILES integer
  | MAXLOGMEMBERS integer
  | MAXLOGHISTORY integer
  | MAXDATAFILES integer
  | MAXINSTANCES integer
  | { ARCHIVELOG | NOARCHIVELOG }
  | FORCE LOGGING
  ]...
  [ character_set_clause ] ;
#+END_SRC

- [CREATE DATABASE]

#+BEGIN_SRC sql
CREATE DATABASE [ database ]
  { USER SYS IDENTIFIED BY password
  | USER SYSTEM IDENTIFIED BY password
  | CONTROLFILE REUSE
  | MAXDATAFILES integer
  | MAXINSTANCES integer
  | CHARACTER SET charset
  | NATIONAL CHARACTER SET charset
  | SET DEFAULT
      { BIGFILE | SMALLFILE } TABLESPACE
  | database_logging_clauses
  | tablespace_clauses
  | set_time_zone_clause
  }... ;
#+END_SRC

- [CREATE DATABASE LINK]

#+BEGIN_SRC sql
CREATE [ SHARED ] [ PUBLIC ] DATABASE LINK dblink
  [ CONNECT TO
    { CURRENT_USER
    | user IDENTIFIED BY password [ dblink_authentication ]
    }
  | dblink_authentication
  ]...
  [ USING connect_string ] ;
#+END_SRC

- [CREATE DIMENSION]

#+BEGIN_SRC sql
CREATE DIMENSION [ schema. ] dimension
  level_clause ...
  { hierarchy_clause
  | attribute_clause
  | extended_attribute_clause
  }...
;
#+END_SRC

- [CREATE DIRECTORY]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] DIRECTORY directory
  AS 'path_name' ;
#+END_SRC

- [CREATE DISKGROUP]

#+BEGIN_SRC sql
CREATE DISKGROUP diskgroup_name
  [ { HIGH | NORMAL | EXTERNAL } REDUNDANCY ]
  { [ QUORUM | REGULAR ][  FAILGROUP failgroup_name ]
  DISK qualified_disk_clause [, qualified_disk_clause]...
  } ...
  [ ATTRIBUTE { 'attribute_name' = 'attribute_value' }
              [, 'attribute_name' = 'attribute_value' ]... ]
;
#+END_SRC

- [CREATE EDITION]

#+BEGIN_SRC sql
CREATE EDITION edition
  [ AS CHILD OF parent_edition ] ;
#+END_SRC

- [CREATE FLASHBACK ARCHIVE]

#+BEGIN_SRC sql
CREATE FLASHBACK ARCHIVE [DEFAULT] flashback_archive
  TABLESPACE tablespace
  [flashback_archive_quota]
  [ [NO] OPTIMIZE DATA ]
  flashback_archive_retention
;
#+END_SRC

#+BEGIN_SRC txt


Note:

You can specify the `[NO]` `OPTIMIZE` `DATA` clause in this statement starting with Oracle Database 11g Release 2 (11.2.0.4).
#+END_SRC

- [CREATE FUNCTION]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] FUNCTION plsql_source
#+END_SRC

- [CREATE INDEX]

#+BEGIN_SRC sql
CREATE [ UNIQUE | BITMAP ] INDEX [ schema. ] index
  ON { cluster_index_clause
     | table_index_clause
     | bitmap_join_index_clause
     }
[ UNUSABLE ] ;
#+END_SRC

- [CREATE INDEXTYPE]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] INDEXTYPE [ schema. ] indextype
  FOR [ schema. ] operator (paramater_type [, paramater_type ]...)
        [, [ schema. ] operator (paramater_type [, paramater_type ]...)
        ]...
  using_type_clause
  [WITH LOCAL [RANGE] PARTITION ]
  [ storage_table_clause ]
;
#+END_SRC

- [CREATE JAVA]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] [ AND { RESOLVE | COMPILE } ] [ NOFORCE ]
  JAVA { { SOURCE | RESOURCE } NAMED [ schema. ] primary_name
       | CLASS [ SCHEMA schema ]
       }
  [ invoker_rights_clause ]
  [ RESOLVER ( (match_string [,] { schema_name | - })...) ]
  { USING { BFILE (directory_object_name, server_file_name)
          | { CLOB | BLOB | BFILE } subquery
          | 'key_for_BLOB'
          }
  | AS source_char
  } ;
#+END_SRC

- [CREATE LIBRARY]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] LIBRARY plsql_source
#+END_SRC

- [CREATE MATERIALIZED VIEW]

#+BEGIN_SRC sql
CREATE MATERIALIZED VIEW [ schema. ] materialized_view
  [ OF [ schema. ] object_type ]
  [ ( { scoped_table_ref_constraint
      | column_alias [ENCRYPT [encryption_spec]]
      }
      [, { scoped_table_ref_constraint
         | column_alias [ENCRYPT [encryption_spec]]
         }
      ]...
    )
  ]
  { ON PREBUILT TABLE
    [ { WITH | WITHOUT } REDUCED PRECISION ]
  | physical_properties materialized_view_props
  }
  [ USING INDEX
    [ physical_attributes_clause
    | TABLESPACE tablespace
    ]...
  | USING NO INDEX
  ]
  [ create_mv_refresh ]
  [ FOR UPDATE ]
  [ { DISABLE | ENABLE } QUERY REWRITE ]
AS subquery ;
#+END_SRC

- [CREATE MATERIALIZED VIEW LOG]

#+BEGIN_SRC sql
CREATE MATERIALIZED VIEW LOG ON [ schema. ] table
  [ physical_attributes_clause
  | TABLESPACE tablespace
  | logging_clause
  | { CACHE | NOCACHE }
  ]...
  [ parallel_clause ]
  [ table_partitioning_clauses ]
  [ WITH [ { OBJECT ID
         | PRIMARY KEY
         | ROWID
         | SEQUENCE
         | COMMIT SCN
         }
           [ { , OBJECT ID
             | , PRIMARY KEY
             | , ROWID
             | , SEQUENCE
             | , COMMIT SCN
             }
           ]... ]
    (column [, column ]...)
    [ new_values_clause ]
  ] [ mv_log_purge_clause ]
;
#+END_SRC

- [CREATE OPERATOR]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] OPERATOR
   [ schema. ] operator binding_clause ;
#+END_SRC

- [CREATE OUTLINE]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ]
   [ PUBLIC | PRIVATE ] OUTLINE [ outline ]
   [ FROM [ PUBLIC | PRIVATE ] source_outline ]
   [ FOR CATEGORY category ]
   [ ON statement ] ;
#+END_SRC

- [CREATE PACKAGE]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] PACKAGE plsql_source
#+END_SRC

- [CREATE PACKAGE BODY]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] PACKAGE BODY plsql_source
#+END_SRC

- [CREATE PFILE]

#+BEGIN_SRC sql
CREATE PFILE [= 'pfile_name' ]
   FROM { SPFILE [= 'spfile_name']
        | MEMORY
        } ;
#+END_SRC

- [CREATE PROCEDURE]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] PROCEDURE plsql_source
#+END_SRC

- [CREATE PROFILE]

#+BEGIN_SRC sql
CREATE PROFILE profile
   LIMIT { resource_parameters
         | password_parameters
         }...
;
#+END_SRC

- [CREATE RESTORE POINT]

#+BEGIN_SRC sql
CREATE RESTORE POINT restore_point
   [ AS OF {TIMESTAMP | SCN} expr ]
   [ PRESERVE
   | GUARANTEE FLASHBACK DATABASE
   ];
#+END_SRC

- [CREATE ROLE]

#+BEGIN_SRC sql
CREATE ROLE role
   [ NOT IDENTIFIED
   | IDENTIFIED { BY password
                | USING [ schema. ] package
                | EXTERNALLY
                | GLOBALLY
                }
   ] ;
#+END_SRC

- [CREATE ROLLBACK SEGMENT]

#+BEGIN_SRC sql
CREATE [ PUBLIC ] ROLLBACK SEGMENT rollback_segment
  [ TABLESPACE tablespace | storage_clause ]...];
#+END_SRC

- [CREATE SCHEMA]

#+BEGIN_SRC sql
CREATE SCHEMA AUTHORIZATION schema
   { create_table_statement
   | create_view_statement
   | grant_statement
   }...
;
#+END_SRC

- [CREATE SEQUENCE]

#+BEGIN_SRC sql
CREATE SEQUENCE [ schema. ] sequence
   [ { INCREMENT BY | START WITH } integer
   | { MAXVALUE integer | NOMAXVALUE }
   | { MINVALUE integer | NOMINVALUE }
   | { CYCLE | NOCYCLE }
   | { CACHE integer | NOCACHE }
   | { ORDER | NOORDER }
   ]...
;
#+END_SRC

- [CREATE SPFILE]

#+BEGIN_SRC sql
CREATE SPFILE [= 'spfile_name' ]
  FROM { PFILE [= 'pfile_name' ]
       | MEMORY
       } ;
#+END_SRC

- [CREATE SYNONYM]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] [ PUBLIC ] SYNONYM
   [ schema. ] synonym
   FOR [ schema. ] object [ @ dblink ] ;
#+END_SRC

- [CREATE TABLE]
#+BEGIN_SRC sql
BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE daily';
EXCEPTION
   WHEN OTHERS THEN NULL;
END;
/
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE daily (
  id number(10) check (id > 0) NOT NULL,
  title varchar2(128) DEFAULT NULL,
  user_id varchar2(45) DEFAULT NULL,
  createtime varchar2(45) DEFAULT NULL,
  imgurl clob,
  body clob,
  url varchar2(256) DEFAULT NULL,
  status number(3) DEFAULT '0',
  rank number(3) DEFAULT '0' check (rank > 0),
  PRIMARY KEY (id)
) ;

-- Generate ID using sequence and trigger
CREATE SEQUENCE daily_seq START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE TRIGGER daily_seq_tr
 BEFORE INSERT ON daily FOR EACH ROW
 WHEN (NEW.id IS NULL)
BEGIN
 SELECT daily_seq.NEXTVAL INTO :NEW.id FROM DUAL;
END;
/

CREATE INDEX dailytitle ON daily (title);
#+END_SRC

#+BEGIN_SRC sql
CREATE [ GLOBAL TEMPORARY ] TABLE [ schema. ] table
  { relational_table | object_table | XMLType_table } ;
#+END_SRC
check sql which created this table in PLSQL:
right click table -> 然后右键“DBMS_元数据”“DDL”

- [CREATE TABLESPACE]

#+BEGIN_SRC sql
CREATE
   [ BIGFILE | SMALLFILE ]
   { permanent_tablespace_clause
   | temporary_tablespace_clause
   | undo_tablespace_clause
   } ;
#+END_SRC

- [CREATE TRIGGER]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] TRIGGER plsql_source
#+END_SRC

- [CREATE TYPE]

#+BEGIN_SRC sql
CREATE [OR REPLACE] TYPE plsql_source
#+END_SRC

- [CREATE TYPE BODY]

#+BEGIN_SRC sql
CREATE [ OR REPLACE ] TYPE BODY plsql_source
#+END_SRC

- [CREATE USER]

#+BEGIN_SRC sql
CREATE USER user
   IDENTIFIED { BY password
              | EXTERNALLY [ AS 'certificate_DN' | AS 'kerberos_principal_name' ]
              | GLOBALLY [ AS '[ directory_DN ]' ]
              }
   [ DEFAULT TABLESPACE tablespace
   | TEMPORARY TABLESPACE
        { tablespace | tablespace_group_name }
   | { QUOTA { size_clause | UNLIMITED } ON tablespace }...
   | PROFILE profile
   | PASSWORD EXPIRE
   | ACCOUNT { LOCK | UNLOCK }
     [ DEFAULT TABLESPACE tablespace
     | TEMPORARY TABLESPACE
          { tablespace | tablespace_group_name }
     | { QUOTA { size_clause | UNLIMITED } ON tablespace }...
     | PROFILE profile
     | PASSWORD EXPIRE
     | ACCOUNT { LOCK | UNLOCK }
     | ENABLE EDITIONS
     ]...
  ] ;
#+END_SRC

- [CREATE VIEW]

#+BEGIN_SRC sql
CREATE [OR REPLACE]
  [[NO] FORCE] [EDITIONING] VIEW [schema.] view
   [ ( { alias [ inline_constraint... ]
       | out_of_line_constraint
       }
         [, { alias [ inline_constraint...]
            | out_of_line_constraint
     }
  ]
     )
   | object_view_clause
   | XMLType_view_clause
   ]
   AS subquery [ subquery_restriction_clause ] ;
#+END_SRC

- [DELETE]

#+BEGIN_SRC sql
DELETE [ hint ]
   [ FROM ]
   { dml_table_expression_clause
   | ONLY (dml_table_expression_clause)
   } [ t_alias ]
     [ where_clause ]
     [ returning_clause ]
     [error_logging_clause];
#+END_SRC

- [DISASSOCIATE STATISTICS]

#+BEGIN_SRC sql
DISASSOCIATE STATISTICS FROM
   { COLUMNS [ schema. ]table.column
               [, [ schema. ]table.column ]...
   | FUNCTIONS [ schema. ]function
                 [, [ schema. ]function ]...
   | PACKAGES [ schema. ]package
                [, [ schema. ]package ]...
   | TYPES [ schema. ]type
             [, [ schema. ]type ]...
   | INDEXES [ schema. ]index
               [, [ schema. ]index ]...
   | INDEXTYPES [ schema. ]indextype
                  [, [ schema. ]indextype ]...
   }
   [ FORCE ] ;
#+END_SRC

- [DROP CLUSTER]

#+BEGIN_SRC sql
DROP CLUSTER [ schema. ] cluster
   [ INCLUDING TABLES [ CASCADE CONSTRAINTS ] ] ;
#+END_SRC

- [DROP CONTEXT]

#+BEGIN_SRC sql
DROP CONTEXT namespace ;
#+END_SRC

- [DROP DATABASE]

#+BEGIN_SRC sql
DROP DATABASE ;
#+END_SRC

- [DROP DATABASE LINK]

#+BEGIN_SRC sql
DROP [ PUBLIC ] DATABASE LINK dblink ;
#+END_SRC

- [DROP DIMENSION]

#+BEGIN_SRC sql
DROP DIMENSION [ schema. ] dimension ;
#+END_SRC

- [DROP DIRECTORY]

#+BEGIN_SRC sql
DROP DIRECTORY directory_name ;
#+END_SRC

- [DROP DISKGROUP]

#+BEGIN_SRC sql
DROP DISKGROUP diskgroup_name
   [  FORCE INCLUDING CONTENTS
   | { INCLUDING | EXCLUDING } CONTENTS
   ];
#+END_SRC

- [DROP EDITION]

#+BEGIN_SRC sql
DROP EDITION edition [CASCADE];
#+END_SRC

- [DROP FLASHBACK ARCHIVE]

#+BEGIN_SRC sql
DROP FLASHBACK ARCHIVE flashback_archive;
#+END_SRC

- [DROP FUNCTION]

#+BEGIN_SRC sql
DROP FUNCTION [ schema. ] function_name ;
#+END_SRC

- [DROP INDEX]

#+BEGIN_SRC sql
DROP INDEX [ schema. ] index [ FORCE ] ;
#+END_SRC

- [DROP INDEXTYPE]

#+BEGIN_SRC sql
DROP INDEXTYPE [ schema. ] indextype [ FORCE ] ;
#+END_SRC

- [DROP JAVA]

#+BEGIN_SRC sql
DROP JAVA { SOURCE | CLASS | RESOURCE }
  [ schema. ] object_name ;
#+END_SRC

- [DROP LIBRARY]

#+BEGIN_SRC sql
DROP LIBRARY library_name ;
#+END_SRC

- [DROP MATERIALIZED VIEW]

#+BEGIN_SRC sql
DROP MATERIALIZED VIEW [ schema. ] materialized_view
   [ PRESERVE TABLE ] ;
#+END_SRC

- [DROP MATERIALIZED VIEW LOG]

#+BEGIN_SRC sql
DROP MATERIALIZED VIEW LOG ON [ schema. ] table ;
#+END_SRC

- [DROP OPERATOR]

#+BEGIN_SRC sql
DROP OPERATOR [ schema. ] operator [ FORCE ] ;
#+END_SRC

- [DROP OUTLINE]

#+BEGIN_SRC sql
DROP OUTLINE outline ;
#+END_SRC

- [DROP PACKAGE]

#+BEGIN_SRC sql
DROP PACKAGE [ BODY ] [ schema. ] package ;
#+END_SRC

- [DROP PROCEDURE]

#+BEGIN_SRC sql
DROP PROCEDURE [ schema. ] procedure ;
#+END_SRC

- [DROP PROFILE]

#+BEGIN_SRC sql
DROP PROFILE profile [ CASCADE ] ;
#+END_SRC

- [DROP RESTORE POINT]

#+BEGIN_SRC sql
DROP RESTORE POINT restore_point ;
#+END_SRC

- [DROP ROLE]

#+BEGIN_SRC sql
DROP ROLE role ;
#+END_SRC

- [DROP ROLLBACK SEGMENT]

#+BEGIN_SRC sql
DROP ROLLBACK SEGMENT rollback_segment ;
#+END_SRC

- [DROP SEQUENCE]

#+BEGIN_SRC sql
DROP SEQUENCE [ schema. ] sequence_name ;
#+END_SRC

- [DROP SYNONYM]

#+BEGIN_SRC sql
DROP [PUBLIC] SYNONYM [ schema. ] synonym [FORCE] ;
#+END_SRC

- [DROP TABLE]

#+BEGIN_SRC sql
DROP TABLE [ schema. ] table
  [ CASCADE CONSTRAINTS ] [ PURGE ] ;
#+END_SRC
drop table if exists
#+BEGIN_SRC sql
BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE ' || table_name;
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

#+END_SRC
- [DROP TABLESPACE]

#+BEGIN_SRC sql
DROP TABLESPACE tablespace
   [ INCLUDING CONTENTS [ {AND | KEEP} DATAFILES ]
     [ CASCADE CONSTRAINTS ]
   ] ;
#+END_SRC

- [DROP TRIGGER]

#+BEGIN_SRC sql
DROP TRIGGER [ schema. ] trigger ;
#+END_SRC

- [DROP TYPE]

#+BEGIN_SRC sql
DROP TYPE [ schema. ] type_name [ FORCE | VALIDATE ] ;
#+END_SRC

- [DROP TYPE BODY]

#+BEGIN_SRC sql
DROP TYPE BODY [ schema. ] type_name ;
#+END_SRC

- [DROP USER]

#+BEGIN_SRC sql
DROP USER user [ CASCADE ] ;
#+END_SRC

- [DROP VIEW]

#+BEGIN_SRC sql
DROP VIEW [ schema. ] view [ CASCADE CONSTRAINTS ] ;
#+END_SRC

- [EXPLAIN PLAN]

#+BEGIN_SRC sql
EXPLAIN PLAN
   [ SET STATEMENT_ID = string ]
   [ INTO [ schema. ] table [ @ dblink ] ]
FOR statement ;
#+END_SRC

- [FLASHBACK DATABASE]

#+BEGIN_SRC sql
FLASHBACK [ STANDBY ] DATABASE [ database ]
   { TO { { SCN | TIMESTAMP } expr
        | RESTORE POINT restore_point
        }
   | TO BEFORE { SCN | TIMESTAMP} expr
               | RESETLOGS
               }
   } ;
#+END_SRC

- [FLASHBACK TABLE]

#+BEGIN_SRC sql
FLASHBACK TABLE
   [ schema. ] table
     [, [ schema. ] table ]...
   TO { { { SCN | TIMESTAMP } expr
        | RESTORE POINT restore_point
        } [ { ENABLE | DISABLE } TRIGGERS ]
      | BEFORE DROP [ RENAME TO table ]
      } ;
#+END_SRC

- [GRANT]

#+BEGIN_SRC sql
GRANT { grant_system_privileges
      | grant_object_privileges
      } ;
#+END_SRC

- [INSERT]

#+BEGIN_SRC sql
INSERT [ hint ]
   { single_table_insert | multi_table_insert } ;
#+END_SRC

- [LOCK TABLE]

#+BEGIN_SRC sql
LOCK TABLE [ schema. ] { table | view }
   [ partition_extension_clause
   | @ dblink
   ] [, [ schema. ] { table | view }
      [ partition_extension_clause
      | @ dblink
      ]
     ]...
   IN lockmode MODE
   [ NOWAIT
   | WAIT integer
   ] ;
#+END_SRC

- [MERGE]

#+BEGIN_SRC sql
MERGE [ hint ]
   INTO [ schema. ] { table | view } [ t_alias ]
   USING { [ schema. ] { table | view }
         | subquery
         } [ t_alias ]
   ON ( condition )
   [ merge_update_clause ]
   [ merge_insert_clause ]
   [ error_logging_clause ] ;
#+END_SRC

- [NOAUDIT]

#+BEGIN_SRC sql
NOAUDIT
   { audit_operation_clause [ auditing_by_clause ]
   | audit_schema_object_clause
   | NETWORK
   }
   [ WHENEVER [ NOT ] SUCCESSFUL ] ;
#+END_SRC

- [PURGE]

#+BEGIN_SRC sql
PURGE { { TABLE table | INDEX index }
      | { RECYCLEBIN | DBA_RECYCLEBIN }
      | TABLESPACE tablespace [ USER username ]
      } ;
#+END_SRC

- [RENAME]

#+BEGIN_SRC sql
RENAME old_name TO new_name ;
#+END_SRC

- [REVOKE]

#+BEGIN_SRC sql
REVOKE { revoke_system_privileges
       | revoke_object_privileges
       } ;
#+END_SRC

- [ROLLBACK]

#+BEGIN_SRC sql
ROLLBACK [ WORK ]
   [ TO [ SAVEPOINT ] savepoint
   | FORCE string
   ] ;
#+END_SRC

- [SAVEPOINT]

#+BEGIN_SRC sql
SAVEPOINT savepoint ;
#+END_SRC

- [SELECT]

#+BEGIN_SRC sql
subquery [ for_update_clause ] ;
#+END_SRC

- [SET CONSTRAINT[S]]

#+BEGIN_SRC sql
SET { CONSTRAINT | CONSTRAINTS }
    { constraint [, constraint ]...
    | ALL
    }
    { IMMEDIATE | DEFERRED } ;
#+END_SRC

- [SET ROLE]

#+BEGIN_SRC sql
SET ROLE
   { role [ IDENTIFIED BY password ]
     [, role [ IDENTIFIED BY password ] ]...
   | ALL [ EXCEPT role [, role ]... ]
   | NONE
   } ;
#+END_SRC

- [SET TRANSACTION]

#+BEGIN_SRC sql
SET TRANSACTION
   { { READ { ONLY | WRITE }
     | ISOLATION LEVEL
       { SERIALIZABLE | READ COMMITTED }
     | USE ROLLBACK SEGMENT rollback_segment
     } [ NAME string ]
   | NAME string
   } ;
#+END_SRC

- [TRUNCATE_CLUSTER]

#+BEGIN_SRC sql
TRUNCATE CLUSTER [schema.] cluster
  [ {DROP | REUSE} STORAGE ] ;
#+END_SRC

- [TRUNCATE_TABLE]

#+BEGIN_SRC sql
TRUNCATE TABLE [schema.] table
  [ {PRESERVE | PURGE} MATERIALIZED VIEW LOG ]
  [ {DROP [ ALL ] | REUSE} STORAGE ] ;
#+END_SRC

#+BEGIN_SRC txt


Note:

You can specify the `ALL` keyword in this statement starting with Oracle Database 11g Release 2 (11.2.0.2).
#+END_SRC

- [UPDATE]

#+BEGIN_SRC sql
UPDATE [ hint ]
   { dml_table_expression_clause
   | ONLY (dml_table_expression_clause)
   } [ t_alias ]
   update_set_clause
   [ where_clause ]
   [ returning_clause ]
   [error_logging_clause] ;
#+END_SRC
* SQL Functions
** Syntax for SQL Functions
A function is a command that manipulates data items and returns a single value.

The sections that follow show each SQL function and its related syntax. Refer to [Chapter 5, "Subclauses"](sqlqr05.htm#g1004143) for the syntax of the subclauses.

- [ABS]

#+BEGIN_SRC sql
ABS(n)
#+END_SRC

- [ACOS]

#+BEGIN_SRC sql
ACOS(n)
#+END_SRC

- [ADD_MONTHS]

#+BEGIN_SRC sql
ADD_MONTHS(date, integer)
#+END_SRC

- [aggregate_function]

Aggregate functions return a single result row based on groups of rows, rather than on single rows.

- [analytic_function]

#+BEGIN_SRC sql
analytic_function([ arguments ])
   OVER (analytic_clause)
#+END_SRC

- [APPENDCHILDXML]

#+BEGIN_SRC sql
APPENDCHILDXML
  ( XMLType_instance, XPath_string, value_expr [, namespace_string ])
#+END_SRC

- [ASCII]

#+BEGIN_SRC sql
ASCII(char)
#+END_SRC

- [ASCIISTR]

#+BEGIN_SRC sql
ASCIISTR(char)
#+END_SRC

- [ASIN]

#+BEGIN_SRC sql
ASIN(n)
#+END_SRC

- [ATAN]

#+BEGIN_SRC sql
ATAN(n)
#+END_SRC

- [ATAN2]

#+BEGIN_SRC sql
ATAN2(n1 , n2)
#+END_SRC

- [AVG]

#+BEGIN_SRC sql
AVG([ DISTINCT | ALL ] expr) [ OVER(analytic_clause) ]
#+END_SRC

- [BFILENAME]

#+BEGIN_SRC sql
BFILENAME('directory', 'filename')
#+END_SRC

- [BIN_TO_NUM]

#+BEGIN_SRC sql
BIN_TO_NUM(expr [, expr ]... )
#+END_SRC

- [BITAND]

#+BEGIN_SRC sql
BITAND(expr1, expr2)
#+END_SRC

- [CARDINALITY]

#+BEGIN_SRC sql
CARDINALITY(nested_table)
#+END_SRC

- [CAST]

#+BEGIN_SRC sql
CAST({ expr | MULTISET (subquery) } AS type_name)
#+END_SRC

- [CEIL]

#+BEGIN_SRC sql
CEIL(n)
#+END_SRC

- [CHARTOROWID]

#+BEGIN_SRC sql
CHARTOROWID(char)
#+END_SRC

- [CHR]

#+BEGIN_SRC sql
CHR(n [ USING NCHAR_CS ])
#+END_SRC

- [CLUSTER_ID]

#+BEGIN_SRC sql
CLUSTER_ID ( [ schema . ] model mining_attribute_clause )
#+END_SRC

- [CLUSTER_PROBABILITY]

#+BEGIN_SRC sql
CLUSTER_PROBABILITY ( [ schema . ] model
   [ , cluster_id ] mining_attribute_clause )
#+END_SRC

- [CLUSTER_SET]

#+BEGIN_SRC sql
CLUSTER_SET ( [ schema . ] model [ , topN [ , cutoff ] ] mining_attribute_clause )
#+END_SRC

- [COALESCE]

#+BEGIN_SRC sql
COALESCE(expr [, expr ]...)
#+END_SRC

- [COLLECT]

#+BEGIN_SRC sql
COLLECT( [ DISTINCT | UNIQUE ] column [ ORDER BY expr ] )
#+END_SRC

- [COMPOSE]

#+BEGIN_SRC sql
COMPOSE(char)
#+END_SRC

- [CONCAT]

#+BEGIN_SRC sql
CONCAT(char1, char2)
#+END_SRC

- [CONVERT]

#+BEGIN_SRC sql
CONVERT(char, dest_char_set[, source_char_set ])
#+END_SRC

- [CORR]

#+BEGIN_SRC sql
CORR(expr1, expr2) [ OVER (analytic_clause) ]
#+END_SRC

- [CORR_K], <a id="sthref326"></a><a id="sthref327"></a>[CORR_S]

#+BEGIN_SRC sql
{ CORR_K | CORR_S }
   (expr1, expr2
     [, { COEFFICIENT
        | ONE_SIDED_SIG
        | ONE_SIDED_SIG_POS
        | ONE_SIDED_SIG_NEG
        | TWO_SIDED_SIG
        }
     ]
   )
#+END_SRC

- [COS]

#+BEGIN_SRC sql
COS(n)
#+END_SRC

- [COSH]

#+BEGIN_SRC sql
COSH(n)
#+END_SRC

- [COUNT]

#+BEGIN_SRC sql
COUNT({ * | [ DISTINCT | ALL ] expr }) [ OVER (analytic_clause) ]
#+END_SRC

- [COVAR_POP]

#+BEGIN_SRC sql
COVAR_POP(expr1, expr2)
   [ OVER (analytic_clause) ]
#+END_SRC

- [COVAR_SAMP]

#+BEGIN_SRC sql
COVAR_SAMP(expr1, expr2) [ OVER (analytic_clause) ]
#+END_SRC

- [CUBE_TABLE]

#+BEGIN_SRC sql
CUBE_TABLE
( ' { schema.cube [ {HIERARCHY | HRR} dimension hierarchy ]...
    | schema.dimension [ {HIERARCHY | HRR} [dimension] hierarchy ]
    }
  '
)
#+END_SRC

- [CUME_DIST (aggregate)]

#+BEGIN_SRC sql
CUME_DIST(expr[,expr ]...) WITHIN GROUP
  (ORDER BY expr [ DESC | ASC ]
                 [ NULLS { FIRST | LAST } ]
            [, expr [ DESC | ASC ]
                    [ NULLS { FIRST | LAST } ]
            ]...
  )
#+END_SRC

- [CUME_DIST (analytic)]

#+BEGIN_SRC sql
CUME_DIST() OVER ([ query_partition_clause ] order_by_clause)
#+END_SRC

- [CURRENT_DATE]

#+BEGIN_SRC sql
CURRENT_DATE
#+END_SRC

- [CURRENT_TIMESTAMP]

#+BEGIN_SRC sql
CURRENT_TIMESTAMP [ (precision) ]
#+END_SRC

- [CV]

#+BEGIN_SRC sql
CV([ dimension_column ])
#+END_SRC

- [DATAOBJ_TO_PARTITION]

#+BEGIN_SRC sql
DATAOBJ_TO_PARTITION( table, partition_id )
#+END_SRC

- [DBTIMEZONE]

#+BEGIN_SRC sql
DBTIMEZONE
#+END_SRC

- [DECODE]

#+BEGIN_SRC sql
DECODE(expr, search, result [, search, result ]... [, default ])
#+END_SRC

- [DECOMPOSE]

#+BEGIN_SRC sql
DECOMPOSE( string [, { 'CANONICAL' | 'COMPATIBILITY' } ] )
#+END_SRC

- [DELETEXML]

#+BEGIN_SRC sql
DELETEXML( XMLType_instance, XPath_string [, namespace_string ])
#+END_SRC

- [DENSE_RANK (aggregate)]

#+BEGIN_SRC sql
DENSE_RANK(expr [, expr ]...) WITHIN GROUP
  (ORDER BY expr [ DESC | ASC ]
                 [ NULLS { FIRST | LAST } ]
            [,expr [ DESC | ASC ]
                   [ NULLS { FIRST | LAST } ]
            ]...
  )
#+END_SRC

- [DENSE_RANK (analytic)]

#+BEGIN_SRC sql
DENSE_RANK( ) OVER([ query_partition_clause ] order_by_clause)
#+END_SRC

- [DEPTH]

#+BEGIN_SRC sql
DEPTH(correlation_integer)
#+END_SRC

- [DEREF]

#+BEGIN_SRC sql
DEREF(expr)
#+END_SRC

- [DUMP]

#+BEGIN_SRC sql
DUMP(expr[, return_fmt [, start_position [, length ] ]])
#+END_SRC

- [EMPTY_BLOB], <a id="sthref372"></a><a id="sthref373"></a>[EMPTY_CLOB]

#+BEGIN_SRC sql
{ EMPTY_BLOB | EMPTY_CLOB }( )
#+END_SRC

- [EXISTSNODE]

#+BEGIN_SRC sql
EXISTSNODE
   (XMLType_instance, XPath_string
      [, namespace_string ]
   )
#+END_SRC

- [EXP]

#+BEGIN_SRC sql
EXP(n)
#+END_SRC

- [EXTRACT (datetime)]

#+BEGIN_SRC sql
EXTRACT( { YEAR
         | MONTH
         | DAY
         | HOUR
         | MINUTE
         | SECOND
         | TIMEZONE_HOUR
         | TIMEZONE_MINUTE
         | TIMEZONE_REGION
         | TIMEZONE_ABBR
         }
         FROM { expr }
       )
#+END_SRC

- [EXTRACT (XML)]

#+BEGIN_SRC sql
EXTRACT(XMLType_instance, XPath_string [, namespace_string ])
#+END_SRC

- [EXTRACTVALUE]

#+BEGIN_SRC sql
EXTRACTVALUE(XMLType_instance, XPath_string [, namespace_string ])
#+END_SRC

- [FEATURE_ID]

#+BEGIN_SRC sql
FEATURE_ID( [ schema . ] model mining_attribute_clause )
#+END_SRC

- [FEATURE_SET]

#+BEGIN_SRC sql
FEATURE_SET( [ schema . ] model [, topN [, cutoff ]] mining_attribute_clause )
#+END_SRC

- [FEATURE_VALUE]

#+BEGIN_SRC sql
FEATURE_VALUE( [ schema . ] model [, feature_id ] mining_attribute_clause )
#+END_SRC

- [FIRST]
get the first row from groups:
#+BEGIN_SRC sql
select person_id, clinic_type as HOSP_TYPE_PREFERENCE,
from   (select person_id, clinic_type, count(*) cnt, max(count(*)) over (partition by person_id) max_count
        from   t_first_choice_hosp_type
        group by person_id, clinic_type)
where  cnt = max_count
#+END_SRC
#+BEGIN_SRC sql
aggregate_function
   KEEP
   (DENSE_RANK FIRST ORDER BY
    expr [ DESC | ASC ]
         [ NULLS { FIRST | LAST } ]
    [, expr [ DESC | ASC ]
            [ NULLS { FIRST | LAST } ]
    ]...
   )
   [ OVER ( [query_partition_clause] ) ]
#+END_SRC

- [FIRST_VALUE]

#+BEGIN_SRC sql
FIRST_VALUE
  { (expr) [ {RESPECT | IGNORE} NULLS ]
  | (expr [ {RESPECT | IGNORE} NULLS ])
  }
  OVER (analytic_clause)
#+END_SRC

- [FLOOR]

#+BEGIN_SRC sql
FLOOR(n)
#+END_SRC

- [FROM_TZ]

#+BEGIN_SRC sql
FROM_TZ (timestamp_value, time_zone_value)
#+END_SRC

- [GREATEST]

#+BEGIN_SRC sql
GREATEST(expr [, expr ]...)
#+END_SRC

- [GROUP_ID]

#+BEGIN_SRC sql
GROUP_ID( )
#+END_SRC

- [GROUPING]

#+BEGIN_SRC sql
GROUPING(expr)
#+END_SRC

- [GROUPING_ID]

#+BEGIN_SRC sql
GROUPING_ID(expr [, expr ]...)
#+END_SRC

- [HEXTORAW]

#+BEGIN_SRC sql
HEXTORAW(char)
#+END_SRC

- [INITCAP]

#+BEGIN_SRC sql
INITCAP(char)
#+END_SRC

- [INSERTCHILDXML]

#+BEGIN_SRC sql
INSERTCHILDXML
  ( XMLType_instance, XPath_string, child_expr, value_expr [, namespace_string ] )
#+END_SRC

- [INSERTCHILDXMLAFTER]

#+BEGIN_SRC sql
INSERTCHILDXMLAFTER
  ( XMLType_instance, XPath_string, child_expr, value_expr [, namespace_string ] )
#+END_SRC

- [INSERTCHILDXMLBEFORE]

#+BEGIN_SRC sql
INSERTCHILDXMLBEFORE
  ( XMLType_instance, XPath_string, child_expr, value_expr [, namespace_string ] )
#+END_SRC

- [INSERTXMLAFTER]

#+BEGIN_SRC sql
INSERTXMLAFTER
  ( XMLType_instance, XPath_string, value_expr [, namespace_string ] )
#+END_SRC

- [INSERTXMLBEFORE]

#+BEGIN_SRC sql
INSERTXMLBEFORE
  ( XMLType_instance, XPath_string, value_expr [, namespace_string ] )
#+END_SRC

- [INSTR]

#+BEGIN_SRC sql
{ INSTR
| INSTRB
| INSTRC
| INSTR2
| INSTR4
}
(string , substring [, position [, occurrence ] ])
#+END_SRC

- [ITERATION_NUMBER]

#+BEGIN_SRC sql
ITERATION_NUMBER
#+END_SRC

- [LAG]

#+BEGIN_SRC sql
LAG
  { ( value_expr [, offset [, default]]) [ { RESPECT | IGNORE } NULLS ]
  | ( value_expr [ { RESPECT | IGNORE } NULLS ] [, offset [, default]] )
  }
  OVER ([ query_partition_clause ] order_by_clause)
#+END_SRC

- [LAST]

#+BEGIN_SRC sql
aggregate_function KEEP
  (DENSE_RANK LAST ORDER BY
    expr [ DESC | ASC ]
         [ NULLS { FIRST | LAST } ]
    [, expr [ DESC | ASC ]
            [ NULLS { FIRST | LAST } ]
    ]...
  )
  [ OVER ( [query_partition_clause] ) ]
#+END_SRC

- [LAST_DAY]

#+BEGIN_SRC sql
LAST_DAY(date)
#+END_SRC

- [LAST_VALUE]

#+BEGIN_SRC sql
LAST_VALUE
  { (expr) [ { RESPECT | IGNORE } NULLS ]
  | (expr [ { RESPECT | IGNORE } NULLS ])
  OVER (analytic_clause)
#+END_SRC

- [LEAD]

#+BEGIN_SRC sql
LEAD
  { ( value_expr [, offset [, default]] ) [ { RESPECT | IGNORE } NULLS ]
  | ( value_expr [ { RESPECT | IGNORE } NULLS ] [, offset [, default]] )
  }
  OVER ([ query_partition_clause ] order_by_clause)
#+END_SRC

- [LEAST]

#+BEGIN_SRC sql
LEAST(expr [, expr ]...)
#+END_SRC

- [LENGTH]

#+BEGIN_SRC sql
{ LENGTH
| LENGTHB
| LENGTHC
| LENGTH2
| LENGTH4
}
(char)
#+END_SRC

- [LISTAGG]
join column by groups
#+BEGIN_SRC sql
select grid as person_id,
listagg(jgid,',') within group( order by jgid ) as hospitals
  from rule_final t1 group by t1.grdi
#+END_SRC
#+BEGIN_SRC sql
LISTAGG(measure_expr [, 'delimiter'])
  WITHIN GROUP (order_by_clause) [OVER query_partition_clause]
#+END_SRC

- [LN]

#+BEGIN_SRC sql
LN(n)
#+END_SRC

- [LNNVL]

#+BEGIN_SRC sql
LNNVL(condition)
#+END_SRC

- [LOCALTIMESTAMP]

#+BEGIN_SRC sql
LOCALTIMESTAMP [ (timestamp_precision) ]
#+END_SRC

- [LOG]

#+BEGIN_SRC sql
LOG(n2, n1)
#+END_SRC

- [LOWER]

#+BEGIN_SRC sql
LOWER(char)
#+END_SRC

- [LPAD]

#+BEGIN_SRC sql
LPAD(expr1, n [, expr2 ])
#+END_SRC

- [LTRIM]

#+BEGIN_SRC sql
LTRIM(char [, set ])
#+END_SRC

- [MAKE_REF]

#+BEGIN_SRC sql
MAKE_REF({ table | view } , key [, key ]...)
#+END_SRC

- [MAX]
#+BEGIN_SRC sql
-- select the max count value
select val, title
from   (select val, title, count(*) cnt, max(count(*)) over (partition by val) max_count
        from   a1
        group by val, title)
where  cnt = max_count;

#+END_SRC
#+BEGIN_SRC sql
MAX([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ]
#+END_SRC

- [MEDIAN]

#+BEGIN_SRC sql
MEDIAN(expr) [ OVER (query_partition_clause) ]
#+END_SRC

- [MIN]

#+BEGIN_SRC sql
MIN([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ]
#+END_SRC

- [MOD]

#+BEGIN_SRC sql
MOD(n2, n1)
#+END_SRC

- [MONTHS_BETWEEN]

#+BEGIN_SRC sql
MONTHS_BETWEEN(date1, date2)
#+END_SRC

- [NANVL]

#+BEGIN_SRC sql
NANVL(n2, n1)
#+END_SRC

- [NCHR]

#+BEGIN_SRC sql
NCHR(number)
#+END_SRC

- [NEW_TIME]

#+BEGIN_SRC sql
NEW_TIME(date, timezone1, timezone2)
#+END_SRC

- [NEXT_DAY]

#+BEGIN_SRC sql
NEXT_DAY(date, char)
#+END_SRC

- [NLS_CHARSET_DECL_LEN]

#+BEGIN_SRC sql
NLS_CHARSET_DECL_LEN(byte_count, char_set_id)
#+END_SRC

- [NLS_CHARSET_ID]

#+BEGIN_SRC sql
NLS_CHARSET_ID(string)
#+END_SRC

- [NLS_CHARSET_NAME]

#+BEGIN_SRC sql
NLS_CHARSET_NAME(number)
#+END_SRC

- [NLS_INITCAP]

#+BEGIN_SRC sql
NLS_INITCAP(char [, 'nlsparam' ])
#+END_SRC

- [NLS_LOWER]

#+BEGIN_SRC sql
NLS_LOWER(char [, 'nlsparam' ])
#+END_SRC

- [NLS_UPPER]

#+BEGIN_SRC sql
NLS_UPPER(char [, 'nlsparam' ])
#+END_SRC

- [NLSSORT]

#+BEGIN_SRC sql
NLSSORT(char [, 'nlsparam' ])
#+END_SRC

- [NTH_VALUE]

#+BEGIN_SRC sql
NTH_VALUE(measure_expr, n)
  [ FROM { FIRST | LAST } ][ { RESPECT | IGNORE } NULLS ]
  OVER (analytic_clause)
#+END_SRC

- [NTILE]

#+BEGIN_SRC sql
NTILE(expr) OVER ([ query_partition_clause ] order_by_clause)
#+END_SRC

- [NULLIF]

#+BEGIN_SRC sql
NULLIF(expr1, expr2)
#+END_SRC

- [NUMTODSINTERVAL]

#+BEGIN_SRC sql
NUMTODSINTERVAL(n, 'interval_unit')
#+END_SRC

- [NUMTOYMINTERVAL]

#+BEGIN_SRC sql
NUMTOYMINTERVAL(n, 'interval_unit')
#+END_SRC

- [NVL]

#+BEGIN_SRC sql
NVL(expr1, expr2)
#+END_SRC

- [NVL2]

#+BEGIN_SRC sql
NVL2(expr1, expr2, expr3)
#+END_SRC

- [ORA_DST_AFFECTED]

#+BEGIN_SRC sql
ORA_DST_AFFECTED(datetime_expr)
#+END_SRC

- [ORA_DST_CONVERT]

#+BEGIN_SRC sql
ORA_DST_CONVERT(datetime_expr [, integer [, integer ]])
#+END_SRC

- [ORA_DST_ERROR]

#+BEGIN_SRC sql
ORA_DST_ERROR(datetime_expr)
#+END_SRC

- [ORA_HASH]

#+BEGIN_SRC sql
ORA_HASH(expr [, max_bucket [, seed_value ] ])
#+END_SRC

- [PATH]

#+BEGIN_SRC sql
PATH(correlation_integer)
#+END_SRC

- [PERCENT_RANK (aggregate)]

#+BEGIN_SRC sql
PERCENT_RANK(expr [, expr ]...) WITHIN GROUP
  (ORDER BY
   expr [ DESC | ASC ]
        [NULLS { FIRST | LAST } ]
   [, expr [ DESC | ASC ]
           [NULLS { FIRST | LAST } ]
   ]...
  )
#+END_SRC

- [PERCENT_RANK (analytic)]

#+BEGIN_SRC sql
PERCENT_RANK( ) OVER ([ query_partition_clause ] order_by_clause)
#+END_SRC

- [PERCENTILE_CONT]

#+BEGIN_SRC sql
PERCENTILE_CONT(expr) WITHIN GROUP
  (ORDER BY expr [ DESC | ASC ])
  [ OVER (query_partition_clause) ]
#+END_SRC

- [PERCENTILE_DISC]

#+BEGIN_SRC sql
PERCENTILE_DISC(expr) WITHIN GROUP
  (ORDER BY expr [ DESC | ASC ])
  [ OVER (query_partition_clause) ]
#+END_SRC

- [POWER]

#+BEGIN_SRC sql
POWER(n2, n1)
#+END_SRC

- [POWERMULTISET]

#+BEGIN_SRC sql
POWERMULTISET(expr)
#+END_SRC

- [POWERMULTISET_BY_CARDINALITY]

#+BEGIN_SRC sql
POWERMULTISET_BY_CARDINALITY(expr, cardinality)
#+END_SRC

- [PREDICTION]

#+BEGIN_SRC sql
PREDICTION ( [ schema . ] model [ cost_matrix_clause ] mining_attribute_clause )
#+END_SRC

- [PREDICTION_BOUNDS]

#+BEGIN_SRC sql
PREDICTION_BOUNDS
( [schema.] model
  [, confidence_level [, class_value]]
  mining_attribute_clause
)
#+END_SRC

- [PREDICTION_COST]

#+BEGIN_SRC sql
PREDICTION_COST ( [ schema . ] model [ , class ] cost_matrix_clause
 mining_attribute_clause )
#+END_SRC

- [PREDICTION_DETAILS]

#+BEGIN_SRC sql
PREDICTION_DETAILS ( [ schema . ] model mining_attribute_clause )
#+END_SRC

- [PREDICTION_PROBABILITY]

#+BEGIN_SRC sql
PREDICTION_PROBABILITY ( [ schema . ] model [ , class ]
   mining_attribute_clause )
#+END_SRC

- [PREDICTION_SET]

#+BEGIN_SRC sql
PREDICTION_SET ( [ schema . ] model [ , bestN [ , cutoff ] ]
  [ cost_matrix_clause ] mining_attribute_clause )
#+END_SRC

- [PRESENTNNV]

#+BEGIN_SRC sql
PRESENTNNV(cell_reference, expr1, expr2)
#+END_SRC

- [PRESENTV]

#+BEGIN_SRC sql
PRESENTV(cell_reference, expr1, expr2)
#+END_SRC

- [PREVIOUS]

#+BEGIN_SRC sql
PREVIOUS(cell_reference)
#+END_SRC

- [RANK (aggregate)]

#+BEGIN_SRC sql
RANK(expr [, expr ]...) WITHIN GROUP
   (ORDER BY
    expr [ DESC | ASC ]
         [ NULLS { FIRST | LAST } ]
    [, expr [ DESC | ASC ]
            [ NULLS { FIRST | LAST } ]
    ]...
   )
#+END_SRC

- [RANK (analytic)]

#+BEGIN_SRC sql
RANK( )
   OVER ([ query_partition_clause ] order_by_clause)
#+END_SRC

- [RATIO_TO_REPORT]

#+BEGIN_SRC sql
RATIO_TO_REPORT(expr)
   OVER ([ query_partition_clause ])
#+END_SRC

- [RAWTOHEX]

#+BEGIN_SRC sql
RAWTOHEX(raw)
#+END_SRC

- [RAWTONHEX]

#+BEGIN_SRC sql
RAWTONHEX(raw)
#+END_SRC

- [REF]

#+BEGIN_SRC sql
REF (correlation_variable)
#+END_SRC

- [REFTOHEX]

#+BEGIN_SRC sql
REFTOHEX (expr)
#+END_SRC

- [REGEXP_COUNT]

#+BEGIN_SRC sql
REGEXP_COUNT (source_char, pattern [, position [, match_param]])
#+END_SRC

- [REGEXP_INSTR]

#+BEGIN_SRC sql
REGEXP_INSTR (source_char, pattern
              [, position
                 [, occurrence
                    [, return_opt
                       [, match_param
                          [, subexpr]
                       ]
                    ]
                 ]
              ]
#+END_SRC

- [REGEXP_REPLACE]

#+BEGIN_SRC sql
REGEXP_REPLACE(source_char, pattern
               [, replace_string
                  [, position
                     [, occurrence
                        [, match_param ]
                     ]
                  ]
               ]
              )
#+END_SRC

- [REGEXP_SUBSTR]

#+BEGIN_SRC sql
REGEXP_SUBSTR(source_char, pattern
              [, position
                 [, occurrence
                    [, match_param
                       [, subexpr
                       ]
                    ]
                 ]
              ]
             )
#+END_SRC

- [REGR_AVGX], <a id="sthref568"></a><a id="sthref569"></a>[REGR_AVGY], <a id="sthref570"></a><a id="sthref571"></a>[REGR_COUNT], <a id="sthref572"></a><a id="sthref573"></a>[REGR_INTERCEPT], <a id="sthref574"></a><a id="sthref575"></a>[REGR_R2], <a id="sthref576"></a><a id="sthref577"></a>[REGR_SLOPE], <a id="sthref578"></a><a id="sthref579"></a>[REGR_SXX], <a id="sthref580"></a><a id="sthref581"></a>[REGR_SXY], <a id="sthref582"></a><a id="sthref583"></a>[REGR_SYY]

#+BEGIN_SRC sql
{ REGR_SLOPE
| REGR_INTERCEPT
| REGR_COUNT
| REGR_R2
| REGR_AVGX
| REGR_AVGY
| REGR_SXX
| REGR_SYY
| REGR_SXY
}
(expr1 , expr2)
[ OVER (analytic_clause) ]
#+END_SRC

- [REMAINDER]

#+BEGIN_SRC sql
REMAINDER(n2, n1)
#+END_SRC

- [REPLACE]

#+BEGIN_SRC sql
REPLACE(char, search_string
        [, replacement_string ]
       )
#+END_SRC

- [ROUND (date)]

#+BEGIN_SRC sql
ROUND(date [, fmt ])
#+END_SRC

- [ROUND (number)]

#+BEGIN_SRC sql
ROUND(n [, integer ])
#+END_SRC

- [ROW_NUMBER]

#+BEGIN_SRC sql
ROW_NUMBER( )
   OVER ([ query_partition_clause ] order_by_clause)
#+END_SRC

- [ROWIDTOCHAR]

#+BEGIN_SRC sql
ROWIDTOCHAR(rowid)
#+END_SRC

- [ROWIDTONCHAR]

#+BEGIN_SRC sql
ROWIDTONCHAR(rowid)
#+END_SRC

- [RPAD]

#+BEGIN_SRC sql
RPAD(expr1 , n [, expr2 ])
#+END_SRC

- [RTRIM]

#+BEGIN_SRC sql
RTRIM(char [, set ])
#+END_SRC

- [SCN_TO_TIMESTAMP]

#+BEGIN_SRC sql
SCN_TO_TIMESTAMP(number)
#+END_SRC

- [SESSIONTIMEZONE]

#+BEGIN_SRC sql
SESSIONTIMEZONE
#+END_SRC

- [SET]

#+BEGIN_SRC sql
SET (nested_table)
#+END_SRC

- [SIGN]

#+BEGIN_SRC sql
SIGN(n)
#+END_SRC

- [SIN]

#+BEGIN_SRC sql
SIN(n)
#+END_SRC

- [SINH]

#+BEGIN_SRC sql
SINH(n)
#+END_SRC

- [SOUNDEX]

#+BEGIN_SRC sql
SOUNDEX(char)
#+END_SRC

- [SQRT]

#+BEGIN_SRC sql
SQRT(n)
#+END_SRC

- [STATS_BINOMIAL_TEST]

#+BEGIN_SRC sql
STATS_BINOMIAL_TEST(expr1, expr2, p
                    [, { TWO_SIDED_PROB
                       | EXACT_PROB
                       | ONE_SIDED_PROB_OR_MORE
                       | ONE_SIDED_PROB_OR_LESS
                       }
                    ]
                   )
#+END_SRC

- [STATS_CROSSTAB]

#+BEGIN_SRC sql
STATS_CROSSTAB(expr1, expr2
               [, { CHISQ_OBS
                  | CHISQ_SIG
                  | CHISQ_DF
                  | PHI_COEFFICIENT
                  | CRAMERS_V
                  | CONT_COEFFICIENT
                  | COHENS_K
                  }
               ]
              )
#+END_SRC

- [STATS_F_TEST]

#+BEGIN_SRC sql
STATS_F_TEST(expr1, expr2
             [, { { STATISTIC
                  | DF_NUM
                  | DF_DEN
                  | ONE_SIDED_SIG
    } , expr3
                | TWO_SIDED_SIG
                }
             ]
            )
#+END_SRC

- [STATS_KS_TEST]

#+BEGIN_SRC sql
STATS_KS_TEST(expr1, expr2
              [, { STATISTIC | SIG } ]
             )
#+END_SRC

- [STATS_MODE]

#+BEGIN_SRC sql
STATS_MODE(expr)
#+END_SRC

- [STATS_MW_TEST]

#+BEGIN_SRC sql
STATS_MW_TEST(expr1, expr2
              [, { STATISTIC
                 | U_STATISTIC
                 | ONE_SIDED_SIG , expr3
                 | TWO_SIDED_SIG
                 }
              ]
             )
#+END_SRC

- [STATS_ONE_WAY_ANOVA]

#+BEGIN_SRC sql
STATS_ONE_WAY_ANOVA(expr1, expr2
                    [, { SUM_SQUARES_BETWEEN
                       | SUM_SQUARES_WITHIN
                       | DF_BETWEEN
                       | DF_WITHIN
                       | MEAN_SQUARES_BETWEEN
                       | MEAN_SQUARES_WITHIN
                       | F_RATIO
                       | SIG
                       }
                    ]
                   )
#+END_SRC

- [STATS_T_TEST_INDEP], <a id="sthref634"></a><a id="sthref635"></a>[STATS_T_TEST_INDEPU], <a id="sthref636"></a><a id="sthref637"></a>[STATS_T_TEST_ONE], <a id="sthref638"></a><a id="sthref639"></a>[STATS_T_TEST_PAIRED]

#+BEGIN_SRC sql
{
  STATS_T_TEST_ONE ( expr1 [, expr2 ]
|
  { { STATS_T_TEST_PAIRED
    | STATS_T_TEST_INDEP
    | STATS_T_TEST_INDEPU
    } ( expr1, expr2
  }
}
[, { { STATISTIC | ONE_SIDED_SIG } , expr3 | TWO_SIDED_SIG | DF } ] )
#+END_SRC

- [STATS_WSR_TEST]

#+BEGIN_SRC sql
STATS_WSR_TEST(expr1, expr2
               [, { STATISTIC
                  | ONE_SIDED_SIG
                  | TWO_SIDED_SIG
                  }
               ]
              )
#+END_SRC

- [STDDEV]

#+BEGIN_SRC sql
STDDEV([ DISTINCT | ALL ] expr)
   [ OVER (analytic_clause) ]
#+END_SRC

- [STDDEV_POP]

#+BEGIN_SRC sql
STDDEV_POP(expr)
   [ OVER (analytic_clause) ]
#+END_SRC

- [STDDEV_SAMP]

#+BEGIN_SRC sql
STDDEV_SAMP(expr)
   [ OVER (analytic_clause) ]
#+END_SRC

- [SUBSTR]

#+BEGIN_SRC sql
{ SUBSTR
| SUBSTRB
| SUBSTRC
| SUBSTR2
| SUBSTR4
}
(char, position [, substring_length ])
#+END_SRC

- [SUM]

#+BEGIN_SRC sql
SUM([ DISTINCT | ALL ] expr)
   [ OVER (analytic_clause) ]
#+END_SRC

- [SYS_CONNECT_BY_PATH]

#+BEGIN_SRC sql
SYS_CONNECT_BY_PATH(column, char)
#+END_SRC

- [SYS_CONTEXT]

#+BEGIN_SRC sql
SYS_CONTEXT('namespace', 'parameter' [, length ])
#+END_SRC

- [SYS_DBURIGEN]

#+BEGIN_SRC sql
SYS_DBURIGEN({ column | attribute }
             [ rowid ]
               [, { column | attribute }
                  [ rowid ]
               ]...
             [, 'text ( )' ]
            )
#+END_SRC

- [SYS_EXTRACT_UTC]

#+BEGIN_SRC sql
SYS_EXTRACT_UTC(datetime_with_timezone)
#+END_SRC

- [SYS_GUID]

#+BEGIN_SRC sql
SYS_GUID( )
#+END_SRC

- [SYS_TYPEID]

#+BEGIN_SRC sql
SYS_TYPEID(object_type_value)
#+END_SRC

- [SYS_XMLAGG]

#+BEGIN_SRC sql
SYS_XMLAGG(expr [, fmt ])
#+END_SRC

- [SYS_XMLGEN]

#+BEGIN_SRC sql
SYS_XMLGEN(expr [, fmt ])
#+END_SRC

- [SYSDATE]

#+BEGIN_SRC sql
SYSDATE
#+END_SRC

- [SYSTIMESTAMP]

#+BEGIN_SRC sql
SYSTIMESTAMP
#+END_SRC

- [TAN]

#+BEGIN_SRC sql
TAN(n)
#+END_SRC

- [TANH]

#+BEGIN_SRC sql
TANH(n)
#+END_SRC

- [TIMESTAMP_TO_SCN]

#+BEGIN_SRC sql
TIMESTAMP_TO_SCN(timestamp)
#+END_SRC

- [TO_BINARY_DOUBLE]

#+BEGIN_SRC sql
TO_BINARY_DOUBLE(expr [, fmt [, 'nlsparam' ] ])
#+END_SRC

- [TO_BINARY_FLOAT]

#+BEGIN_SRC sql
TO_BINARY_FLOAT(expr [, fmt [, 'nlsparam' ] ])
#+END_SRC

- [TO_BLOB]

#+BEGIN_SRC sql
TO_BLOB ( raw_value )
#+END_SRC

- [TO_CHAR (character)]

#+BEGIN_SRC sql
TO_CHAR(nchar | clob | nclob)
#+END_SRC

- [TO_CHAR (datetime)]

#+BEGIN_SRC sql
TO_CHAR({ datetime | interval } [, fmt [, 'nlsparam' ] ])
#+END_SRC

- [TO_CHAR (number)]

#+BEGIN_SRC sql
TO_CHAR(n [, fmt [, 'nlsparam' ] ])
#+END_SRC

- [TO_CLOB]

#+BEGIN_SRC sql
TO_CLOB(lob_column | char)
#+END_SRC

- [TO_DATE]

#+BEGIN_SRC sql
TO_DATE(char [, fmt [, 'nlsparam' ] ])
to_date(char, "YYYYMMDDHHMISS")
#+END_SRC

- [TO_DSINTERVAL]

#+BEGIN_SRC sql
TO_DSINTERVAL ( ' { sql_format | ds_iso_format } ' )
#+END_SRC

- [TO_LOB]

#+BEGIN_SRC sql
TO_LOB(long_column)
#+END_SRC

- [TO_MULTI_BYTE]

#+BEGIN_SRC sql
TO_MULTI_BYTE(char)
#+END_SRC

- [TO_NCHAR (character)]

#+BEGIN_SRC sql
TO_NCHAR({char | clob | nclob})
#+END_SRC

- [TO_NCHAR (datetime)]

#+BEGIN_SRC sql
TO_NCHAR({ datetime | interval }
         [, fmt [, 'nlsparam' ] ]
        )
#+END_SRC

- [TO_NCHAR (number)]

#+BEGIN_SRC sql
TO_NCHAR(n [, fmt [, 'nlsparam' ] ])
#+END_SRC

- [TO_NCLOB]

#+BEGIN_SRC sql
TO_NCLOB(lob_column | char)
#+END_SRC

- [TO_NUMBER]

#+BEGIN_SRC sql
TO_NUMBER(expr [, fmt [, 'nlsparam' ] ])
#+END_SRC

- [TO_SINGLE_BYTE]

#+BEGIN_SRC sql
TO_SINGLE_BYTE(char)
#+END_SRC

- [TO_TIMESTAMP]

#+BEGIN_SRC sql
TO_TIMESTAMP(char [, fmt [, 'nlsparam' ] ])
#+END_SRC

- [TO_TIMESTAMP_TZ]

#+BEGIN_SRC sql
TO_TIMESTAMP_TZ(char [, fmt [, 'nlsparam' ] ])
#+END_SRC

- [TO_YMINTERVAL]

#+BEGIN_SRC sql
TO_YMINTERVAL
  ( '  { [+|-] years - months
       | ym_iso_format
       } ' )
#+END_SRC

- [TRANSLATE]

#+BEGIN_SRC sql
TRANSLATE(expr, from_string, to_string)
#+END_SRC

- [TRANSLATE ... USING]

#+BEGIN_SRC sql
TRANSLATE ( char USING
          { CHAR_CS | NCHAR_CS }
          )
#+END_SRC

- [TREAT]

#+BEGIN_SRC sql
TREAT(expr AS [ REF ] [ schema. ]type)
#+END_SRC

- [TRIM]

#+BEGIN_SRC sql
TRIM([ { { LEADING | TRAILING | BOTH }
         [ trim_character ]
       | trim_character
       }
       FROM
     ]
     trim_source
    )
#+END_SRC

- [TRUNC (date)]

#+BEGIN_SRC sql
TRUNC(date [, fmt ])
#+END_SRC

- [TRUNC (number)]

#+BEGIN_SRC sql
TRUNC(n1 [, n2 ])
#+END_SRC

- [TZ_OFFSET]

#+BEGIN_SRC sql
TZ_OFFSET({ 'time_zone_name'
          | '{ + | - } hh : mi'
          | SESSIONTIMEZONE
          | DBTIMEZONE
          }
         )
#+END_SRC

- [UID]

#+BEGIN_SRC sql
UID
#+END_SRC

- [UNISTR]

#+BEGIN_SRC sql
UNISTR( string )
#+END_SRC

- [UPDATEXML]

#+BEGIN_SRC sql
UPDATEXML
      (XMLType_instance,
        XPath_string, value_expr
          [, XPath_string, value_expr ]...
        [, namespace_string ]
      )
#+END_SRC

- [UPPER]

#+BEGIN_SRC sql
UPPER(char)
#+END_SRC

- [USER]

#+BEGIN_SRC sql
USER
#+END_SRC

- [user-defined function]

#+BEGIN_SRC sql
[ schema. ]
{ [ package. ]function | user_defined_operator }
[ @ dblink. ]
[ ( [ [ DISTINCT | ALL ] expr [, expr ]... ] ) ]
#+END_SRC

- [USERENV]

#+BEGIN_SRC sql
USERENV('parameter')
#+END_SRC

- [VALUE]

#+BEGIN_SRC sql
VALUE(correlation_variable)
#+END_SRC

- [VAR_POP]

#+BEGIN_SRC sql
VAR_POP(expr) [ OVER (analytic_clause) ]
#+END_SRC

- [VAR_SAMP]

#+BEGIN_SRC sql
VAR_SAMP(expr) [ OVER (analytic_clause) ]
#+END_SRC

- [VARIANCE]

#+BEGIN_SRC sql
VARIANCE([ DISTINCT | ALL ] expr)
        [ OVER (analytic_clause) ]
#+END_SRC

- [VSIZE]

#+BEGIN_SRC sql
VSIZE(expr)
#+END_SRC

- [WIDTH_BUCKET]

#+BEGIN_SRC sql
WIDTH_BUCKET
   (expr, min_value, max_value, num_buckets)
#+END_SRC

- [XMLAGG]

#+BEGIN_SRC sql
XMLAGG(XMLType_instance [ order_by_clause ])
#+END_SRC

<a id="SQLQR476"></a>[XMLCAST]<a id="sthref760"></a><a id="sthref761"></a>

#+BEGIN_SRC sql
XMLCAST ( value_expression AS datatype )
#+END_SRC

- [XMLCDATA]

#+BEGIN_SRC sql
XMLCDATA ( value_expr )
#+END_SRC

- [XMLCOLATTVAL]

#+BEGIN_SRC sql
XMLCOLATTVAL
  (value_expr [ AS { c_alias  | EVALNAME value_expr } ]
    [, value_expr [ AS { c_alias  | EVALNAME value_expr } ]
      ]...
  )
#+END_SRC

- [XMLCOMMENT]

#+BEGIN_SRC sql
XMLCOMMENT ( value_expr )
#+END_SRC

- [XMLCONCAT]

#+BEGIN_SRC sql
XMLCONCAT(XMLType_instance [, XMLType_instance ]...)
#+END_SRC

- [XMLDIFF]

#+BEGIN_SRC sql
XMLDIFF ( XMLType_document, XMLType_document [ , integer, string ] )
#+END_SRC

- [XMLELEMENT]

#+BEGIN_SRC sql
XMLELEMENT
 ( [ ENTITYESCAPING | NOENTITYESCAPING ]
   [ NAME ]
     { identifier
     | EVALNAME value_expr
     }
   [, XML_attributes_clause ]
   [, value_expr [ [AS] c_alias ]]...
 )
#+END_SRC

- [XMLEXISTS]

#+BEGIN_SRC sql
XMLEXISTS ( XQuery_string [ XML_passing_clause ] )
#+END_SRC

- [XMLFOREST]

#+BEGIN_SRC sql
XMLFOREST
  ( value_expr [ AS { c_alias | EVALNAME value_expr } ]
    [, value_expr [ AS { c_alias | EVALNAME value_expr } ]
      ]...
  )
#+END_SRC

- [XMLISVALID]

#+BEGIN_SRC sql
XMLISVALID ( XMLType_instance [, XMLSchema_URL [, element ]] )
#+END_SRC

- [XMLPARSE]

#+BEGIN_SRC sql
XMLPARSE
  ({ DOCUMENT | CONTENT } value_expr [ WELLFORMED ]
  )
#+END_SRC

- [XMLPATCH]

#+BEGIN_SRC sql
XMLPATCH ( XMLType_document, XMLType_document )
#+END_SRC

- [XMLPI]

#+BEGIN_SRC sql
XMLPI
 ( { [ NAME ] identifier
   | EVALNAME value_expr
   } [, value_expr ]
 )
#+END_SRC

- [XMLQUERY]

#+BEGIN_SRC sql
XMLQUERY
 ( XQuery_string
   [ XML_passing_clause ]
   RETURNING CONTENT [NULL ON EMPTY]
 )
#+END_SRC

- [XMLROOT]

#+BEGIN_SRC sql
XMLROOT
  ( value_expr, VERSION
  { value_expr | NO VALUE }
  [, STANDALONE { YES | NO | NO VALUE } ]
  )
#+END_SRC

- [XMLSEQUENCE]

#+BEGIN_SRC sql
XMLSEQUENCE( XMLType_instance
           | sys_refcursor_instance [, fmt ]
           )
#+END_SRC

- [XMLSERIALIZE]

#+BEGIN_SRC sql
XMLSERIALIZE
  ( { DOCUMENT | CONTENT } value_expr [ AS datatype ]
    [ ENCODING xml_encoding_spec ]
    [ VERSION string_literal ]
    [ NO INDENT | { INDENT [SIZE = number] } ]
    [ { HIDE | SHOW } DEFAULTS ]
  )
#+END_SRC

- [XMLTABLE]

#+BEGIN_SRC sql
XMLTABLE
 (
  [ XMLnamespaces_clause , ] XQuery_string XMLTABLE_options
 )
#+END_SRC

- [XMLTRANSFORM]

#+BEGIN_SRC sql
XMLTRANSFORM(XMLType_instance, { XMLType_instance
                               | string
                               }
                   )
#+END_SRC
* SQL Expressions
** Syntax for SQL Expression Types
An expression is a combination of one or more values, operators, and SQL functions that evaluate to a value. An expression generally assumes the data type of its components.

Expressions have several forms. The sections that follow show the syntax for each form of expression. Refer to [Chapter 5, "Subclauses"](sqlqr05.htm#g1004143) for the syntax of the subclauses.

- [CASE expressions]
classification of a column:
#+BEGIN_SRC sql
select distinct grid,
                         hznl,
                         case
                           when hznl between 0 and 6 then
                            '童年'
                           when hznl between 7 and 17 then
                            '少年'
                           when hznl between 18 and 40 then
                            '青年'
                           when hznl between 41 and 65 then
                            '中年'
                           when hznl >= 66 then
                            '老年'
                         end as 年龄段
          from rule_final
#+END_SRC
#+BEGIN_SRC sql
CASE { simple_case_expression
     | searched_case_expression
     }
     [ else_clause ]
     END
#+END_SRC

- [Column expressions]

A column expression can be a simple expression, compound expression, function expression, or expression list, containing only columns of the subject table, constants, and deterministic functions.

- [Compound expressions]

#+BEGIN_SRC sql
{ (expr)
| { + | - | PRIOR } expr
| expr { * | / | + | - | || } expr
}

Note: The double vertical bars are part of the syntax
      (indicating concatenation) rather than BNF notation.
#+END_SRC

- [CURSOR expressions]

#+BEGIN_SRC sql
CURSOR (subquery)
#+END_SRC

- [Datetime expressions]

#+BEGIN_SRC sql
expr AT
   { LOCAL
   | TIME ZONE { ' [ + | - ] hh:mi'
               | DBTIMEZONE
               | 'time_zone_name'
               | expr
               }
   }
#+END_SRC

- [Function expressions]

You can use any built-in SQL function or user-defined function as an expression.

- [Interval expressions]

#+BEGIN_SRC sql
( expr1 - expr2 )
   { DAY [ (leading_field_precision) ] TO
     SECOND [ (fractional_second_precision) ]
   | YEAR [ (leading_field_precision) ] TO
     MONTH
   }
#+END_SRC

- [Model expressions]

#+BEGIN_SRC sql
{ measure_column <span class="bold">[</span> { condition | expr } [, { condition | expr } ]... <span class="bold">]</span>
| aggregate_function
     { <span class="bold">[</span> { condition | expr } [, { condition | expr } ]... <span class="bold">]</span>
     | <span class="bold">[</span> single_column_for_loop [, single_column_for_loop ]... <span class="bold">]</span>
     | <span class="bold">[</span> multi_column_for_loop <span class="bold">]</span>
     }
| analytic_function
}
#+END_SRC

- [Object access expressions]

#+BEGIN_SRC sql
{ table_alias.column.
| object_table_alias.
| (expr).
}
{ attribute [.attribute ]...
  [.method ([ argument [, argument ]... ]) ]
| method ([ argument [, argument ]... ])
}
#+END_SRC

- [Placeholder expressions]

#+BEGIN_SRC sql
:host_variable
   [ [ INDICATOR ]
     :indicator_variable
   ]
#+END_SRC

- [Scalar subquery expressions]

A scalar subquery expression is a subquery that returns exactly one column value from one row.

- [Simple expressions]

#+BEGIN_SRC sql
{ [ query_name.
  | [schema.]
    { table. | view. | materialized view. }
  ] { column | ROWID }
| ROWNUM
| string
| number
| sequence. { CURRVAL | NEXTVAL }
| NULL
}
#+END_SRC

- [Type constructor expressions]

#+BEGIN_SRC sql
[ NEW ] [ schema. ]type_name
   ([ expr [, expr ]... ])
#+END_SRC
* SQL Conditions
** Syntax for SQL Condition Types
A condition specifies a combination of one or more expressions and logical (Boolean) operators and returns a value of `TRUE`, `FALSE`, or unknown.

Conditions have several forms. The sections that follow show the syntax for each form of condition. Refer to [Chapter 5, "Subclauses"](sqlqr05.htm#g1004143) for the syntax of the subclauses.

- [BETWEEN condition]

#+BEGIN_SRC sql
expr1 [ NOT ] BETWEEN expr2 AND expr3
#+END_SRC

- [Compound conditions]

#+BEGIN_SRC sql
{ (condition)
| NOT condition
| condition { AND | OR } condition
}
#+END_SRC

- [EQUALS_PATH condition]

#+BEGIN_SRC sql
EQUALS_PATH
    (column, path_string [, correlation_integer ])
#+END_SRC

- [EXISTS condition]

#+BEGIN_SRC sql
EXISTS (subquery)
#+END_SRC

- [Floating-point conditions]

#+BEGIN_SRC sql
expr IS [ NOT ] { NAN | INFINITE }
#+END_SRC

- [Group comparison conditions]

#+BEGIN_SRC sql
{ expr
     { = | != | ^= | <> | > | < | >= | <= }
     { ANY | SOME | ALL }
     ({ expression_list | subquery })
| ( expr [, expr ]... )
  { = | != | ^= | <> }
  { ANY | SOME | ALL }
  ({ expression_list
     [, expression_list ]...
   | subquery
   }
  )
}
#+END_SRC

where `!=`, `^=`, and `<>` test for inequality

- [IN condition]

#+BEGIN_SRC sql
{ expr [ NOT ] IN ({ expression_list | subquery })
| ( expr [, expr ]... )
    [ NOT ] IN ({ expression_list [, expression_list ]...
                | subquery
                }
               )
}
#+END_SRC

- [IS A SET condition]

#+BEGIN_SRC sql
nested_table IS [ NOT ] A SET
#+END_SRC

- [IS ANY condition]

#+BEGIN_SRC sql
[ dimension_column IS ] ANY
#+END_SRC

- [IS EMPTY condition]

#+BEGIN_SRC sql
nested_table IS [ NOT ] EMPTY
#+END_SRC

- [IS OF <span class="italic">type</span> condition]

#+BEGIN_SRC sql
expr IS [ NOT ] OF [ TYPE ]
   ([ ONLY ] [ schema. ] type
      [, [ ONLY ] [ schema. ] type ]...
   )
#+END_SRC

- [IS PRESENT condition]

#+BEGIN_SRC sql
cell_reference IS PRESENT
#+END_SRC

- [LIKE condition]

#+BEGIN_SRC sql
char1 [ NOT ] { LIKE | LIKEC | LIKE2 | LIKE4 }
  char2 [ ESCAPE esc_char ]
#+END_SRC

- [Logical conditions]

#+BEGIN_SRC sql
{ NOT | AND | OR }
#+END_SRC

- [MEMBER condition]

#+BEGIN_SRC sql
expr [ NOT ] MEMBER [ OF ] nested_table
#+END_SRC

- [Null conditions]

#+BEGIN_SRC sql
expr IS [ NOT ] NULL
#+END_SRC

- [REGEXP_LIKE condition]

#+BEGIN_SRC sql
REGEXP_LIKE(source_char, pattern
            [, match_param ]
           )
#+END_SRC

- [Simple comparison conditions]

#+BEGIN_SRC sql
{ expr
  { = | != | ^= | <> | > | < | >= | <= }
  expr
| (expr [, expr ]...)
  { = | != | ^= | <> }
  ( expression_list | subquery )
}
#+END_SRC

where `!=`, `^=`, and `<>` test for inequality

- [SUBMULTISET condition]

#+BEGIN_SRC sql
nested_table1
[ NOT ] SUBMULTISET [ OF ]
nested_table2
#+END_SRC

- [UNDER_PATH condition]

#+BEGIN_SRC sql
UNDER_PATH (column [, levels ], path_string
             [, correlation_integer ]
           )
#+END_SRC
* Subclauses
** Syntax for Subclauses
* Data Types
** Overview of Data Types
A data type is a classification of a particular type of information or data. Each value manipulated by Oracle has a data type. The data type of a value associates a fixed set of properties with the value. These properties cause Oracle to treat values of one data type differently from values of another.

The data types recognized by Oracle are:

- ANSI-supported data types
#+BEGIN_SRC sql
{ CHARACTER [VARYING] (size)
| { CHAR | NCHAR } VARYING (size)
| VARCHAR (size)
| NATIONAL { CHARACTER | CHAR }
     [VARYING] (size)
| { NUMERIC | DECIMAL | DEC }
     [ (precision [, scale ]) ]
| { INTEGER | INT | SMALLINT }
| FLOAT [ (size) ]
| DOUBLE PRECISION
| REAL
}
#+END_SRC
- Oracle built-in data types
#+BEGIN_SRC sql
{ character_datatypes
| number_datatypes
| long_and_raw_datatypes
| datetime_datatypes
| large_object_datatypes
| rowid_datatypes
}
#+END_SRC
- Oracle-supplied data types
#+BEGIN_SRC sql
{ any_types
| XML_types
| spatial_types
| media_types
| expression_filter_type
}
#+END_SRC
- User-defined data types

User-defined data types use Oracle built-in data types and other user-defined data types to model the structure and behavior of data in applications.
** Oracle Built-In Data Types
This section describes the kinds of Oracle built-in data types.

- character_datatypes

#+BEGIN_SRC sql
{ CHAR [ (size [ BYTE | CHAR ]) ]
| VARCHAR2 (size [ BYTE | CHAR ])
| NCHAR [ (size) ]
| NVARCHAR2 (size)
}
#+END_SRC
- datetime_datatypes

#+BEGIN_SRC sql
{ DATE
| TIMESTAMP [ (fractional_seconds_precision) ]
     [ WITH [ LOCAL ] TIME ZONE ]
| INTERVAL YEAR [ (year_precision) ] TO MONTH
| INTERVAL DAY [ (day_precision) ] TO SECOND
     [ (fractional_seconds_precision) ]
}
#+END_SRC

- date range
#+BEGIN_SRC sql
select min(RYRQ) from ck10_ghdj
where RYRQ between date '2010-01-01' and date '2020-01-01'
#+END_SRC

- large_object_datatypes

#+BEGIN_SRC sql
{ BLOB | CLOB | NCLOB | BFILE }
#+END_SRC
- long_and_raw_datatypes

#+BEGIN_SRC sql
{ LONG | LONG RAW | RAW (size) }
#+END_SRC
- number_datatypes

#+BEGIN_SRC sql
{ NUMBER [ (precision [, scale ]) ]
| FLOAT [ (precision) ]
| BINARY_FLOAT
| BINARY_DOUBLE
}
#+END_SRC
- rowid_datatypes

#+BEGIN_SRC sql
{ ROWID | UROWID [ (size) ] }
#+END_SRC
The codes listed for the data types are used internally by Oracle Database. The data type code of a column or object attribute is returned by the DUMP function.
** Oracle-Supplied Data Types

** Converting to Oracle Data Types
* Format Models
** Overview of Format Models
** Number Format Models
** Number Format Elements
** Datetime Format Models
** Datetime Format Elements
* Syntax
- find table name from a column name:
#+BEGIN_SRC sql
select table_name, column_name from dba_tab_columns where column_name like '%THE_COLUMN_YOU_LOOK_FOR(CAPITAL)%';
#+END_SRC
- change language from unknown to Chinese:
create windows environment system variable
NLS_LANG
AMERICAN_AMERICA.AL32UTF8
或 SIMPLIFIED CHINESE_CHINA.ZHS16GBK

- quantile, percentile:

#+BEGIN_SRC sql
SELECT
  f.title,
  ROUND(100.0 * (SELECT COUNT(*) FROM film AS f2 WHERE f2.length <= f.length) / totals.film_count, 1) AS percentile
FROM film f
CROSS JOIN (
  SELECT COUNT(*) AS film_count
  FROM film
) AS totals
ORDER BY percentile DESC;
#+END_SRC
** clickhouse

- show tables and columns:
#+BEGIN_SRC sql
SELECT
   *
FROM
   pg_catalog.pg_tables
WHERE
   schemaname != 'pg_catalog'
AND schemaname != 'information_schema';

select table_schema,
       table_name,
       ordinal_position as position,
       column_name,
       data_type,
       case when character_maximum_length is not null
            then character_maximum_length
            else numeric_precision end as max_length,
       is_nullable,
       column_default as default_value
from information_schema.columns
where table_schema not in ('information_schema', 'pg_catalog')
order by table_schema,
         table_name,
         ordinal_position;


#+END_SRC
